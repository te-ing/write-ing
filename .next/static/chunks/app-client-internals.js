/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app-client-internals"],{

/***/ "./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=next%2Fdist%2Fclient%2Fcomponents%2Fapp-router&modules=next%2Fdist%2Fclient%2Fcomponents%2Flayout-router&modules=next%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context&server=false!":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=next%2Fdist%2Fclient%2Fcomponents%2Fapp-router&modules=next%2Fdist%2Fclient%2Fcomponents%2Flayout-router&modules=next%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context&server=false! ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! next/dist/client/components/app-router */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/app-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! next/dist/client/components/layout-router */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/layout-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! next/dist/client/components/render-from-template-context */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/render-from-template-context.js\", 23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtOGRmMmFlZGM0Ny8wL2NhY2hlL25leHQtbnBtLTEzLjAuMy1mYjg3YTE0MjRhLWYxZjZlOGE1NzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1uZXh0JTJGZGlzdCUyRmNsaWVudCUyRmNvbXBvbmVudHMlMkZhcHAtcm91dGVyJm1vZHVsZXM9bmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGbGF5b3V0LXJvdXRlciZtb2R1bGVzPW5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRnJlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQmc2VydmVyPWZhbHNlIS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzU0FBMkU7QUFDM0UsNFNBQThFO0FBQzlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/YmJmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIm5leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJuZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlclwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwibmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHRcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=next%2Fdist%2Fclient%2Fcomponents%2Fapp-router&modules=next%2Fdist%2Fclient%2Fcomponents%2Flayout-router&modules=next%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context&server=false!\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/app-router-headers.js":
/*!********************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/app-router-headers.js ***!
  \********************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RSC_VARY_HEADER = exports.NEXT_ROUTER_PREFETCH = exports.NEXT_ROUTER_STATE_TREE = exports.RSC = void 0;\nconst RSC = \"RSC\";\nexports.RSC = RSC;\nconst NEXT_ROUTER_STATE_TREE = \"Next-Router-State-Tree\";\nexports.NEXT_ROUTER_STATE_TREE = NEXT_ROUTER_STATE_TREE;\nconst NEXT_ROUTER_PREFETCH = \"Next-Router-Prefetch\";\nexports.NEXT_ROUTER_PREFETCH = NEXT_ROUTER_PREFETCH;\nconst RSC_VARY_HEADER = \"\".concat(RSC, \", \").concat(NEXT_ROUTER_STATE_TREE, \", \").concat(NEXT_ROUTER_PREFETCH);\nexports.RSC_VARY_HEADER = RSC_VARY_HEADER;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-headers.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtOGRmMmFlZGM0Ny8wL2NhY2hlL25leHQtbnBtLTEzLjAuMy1mYjg3YTE0MjRhLWYxZjZlOGE1NzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHQSw0QkFBNEIsR0FBR0EsOEJBQThCLEdBQUdBLFdBQVcsR0FBRyxLQUFLO0FBQzdHLE1BQU1LLE1BQU07QUFDWkwsV0FBVyxHQUFHSztBQUNkLE1BQU1ELHlCQUF5QjtBQUMvQkosOEJBQThCLEdBQUdJO0FBQ2pDLE1BQU1ELHVCQUF1QjtBQUM3QkgsNEJBQTRCLEdBQUdHO0FBQy9CLE1BQU1ELGtCQUFrQixHQUFXRSxPQUFSQyxLQUFJLE1BQStCRixPQUEzQkMsd0JBQXVCLE1BQXlCLE9BQXJCRDtBQUM5REgsdUJBQXVCLEdBQUdFO0FBRTFCLElBQUksQ0FBQyxPQUFPRixRQUFRTSxPQUFPLEtBQUssY0FBZSxPQUFPTixRQUFRTSxPQUFPLEtBQUssWUFBWU4sUUFBUU0sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTixRQUFRTSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLVCxPQUFPQyxjQUFjLENBQUNDLFFBQVFNLE9BQU8sRUFBRSxjQUFjO1FBQUVMLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPVSxNQUFNLENBQUNSLFFBQVFNLE9BQU8sRUFBRU47SUFDL0JTLE9BQU9ULE9BQU8sR0FBR0EsUUFBUU0sT0FBTztBQUNsQyxDQUFDLENBRUQsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC04ZGYyYWVkYzQ3LzAvY2FjaGUvbmV4dC1ucG0tMTMuMC4zLWZiODdhMTQyNGEtZjFmNmU4YTU3NC56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLWhlYWRlcnMuanM/ZWY3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUlNDX1ZBUllfSEVBREVSID0gZXhwb3J0cy5ORVhUX1JPVVRFUl9QUkVGRVRDSCA9IGV4cG9ydHMuTkVYVF9ST1VURVJfU1RBVEVfVFJFRSA9IGV4cG9ydHMuUlNDID0gdm9pZCAwO1xuY29uc3QgUlNDID0gJ1JTQyc7XG5leHBvcnRzLlJTQyA9IFJTQztcbmNvbnN0IE5FWFRfUk9VVEVSX1NUQVRFX1RSRUUgPSAnTmV4dC1Sb3V0ZXItU3RhdGUtVHJlZSc7XG5leHBvcnRzLk5FWFRfUk9VVEVSX1NUQVRFX1RSRUUgPSBORVhUX1JPVVRFUl9TVEFURV9UUkVFO1xuY29uc3QgTkVYVF9ST1VURVJfUFJFRkVUQ0ggPSAnTmV4dC1Sb3V0ZXItUHJlZmV0Y2gnO1xuZXhwb3J0cy5ORVhUX1JPVVRFUl9QUkVGRVRDSCA9IE5FWFRfUk9VVEVSX1BSRUZFVENIO1xuY29uc3QgUlNDX1ZBUllfSEVBREVSID0gYCR7UlNDfSwgJHtORVhUX1JPVVRFUl9TVEFURV9UUkVFfSwgJHtORVhUX1JPVVRFUl9QUkVGRVRDSH1gO1xuZXhwb3J0cy5SU0NfVkFSWV9IRUFERVIgPSBSU0NfVkFSWV9IRUFERVI7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZXItaGVhZGVycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSU0NfVkFSWV9IRUFERVIiLCJORVhUX1JPVVRFUl9QUkVGRVRDSCIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUUiLCJSU0MiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/app-router-headers.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/app-router.js":
/*!************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/app-router.js ***!
  \************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = AppRouter;\nexports.fetchServerResponse = fetchServerResponse;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/compiled/react/index.js\"));\nvar _client = __webpack_require__(/*! next/dist/compiled/react-server-dom-webpack/client */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _reducer = __webpack_require__(/*! ./reducer */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/reducer.js\");\nvar _hooksClientContext = __webpack_require__(/*! ../../shared/lib/hooks-client-context */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/shared/lib/hooks-client-context.js\");\nvar _useReducerWithDevtools = __webpack_require__(/*! ./use-reducer-with-devtools */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/use-reducer-with-devtools.js\");\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/error-boundary.js\");\nvar _appRouterHeaders = __webpack_require__(/*! ./app-router-headers */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/app-router-headers.js\");\nfunction AppRouter(props) {\n    return /*#__PURE__*/ _react.default.createElement(_errorBoundary.ErrorBoundary, {\n        errorComponent: _errorBoundary.GlobalErrorComponent\n    }, /*#__PURE__*/ _react.default.createElement(Router, Object.assign({}, props)));\n}\n_c = AppRouter;\n\"use client\";\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url, location.origin);\n    // TODO-APP: handle .rsc for static export case\n    return urlWithoutFlightParameters;\n}\nconst HotReloader =  false ? 0 : (__webpack_require__(/*! ./react-dev-overlay/hot-reloader-client */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js\")[\"default\"]);\nfunction fetchServerResponse(url, flightRouterState, prefetch) {\n    return _fetchServerResponse.apply(this, arguments);\n}\nfunction _fetchServerResponse() {\n    _fetchServerResponse = _async_to_generator(function*(url, flightRouterState, prefetch) {\n        const headers = {\n            // Enable flight response\n            [_appRouterHeaders.RSC]: \"1\",\n            // Provide the current router state\n            [_appRouterHeaders.NEXT_ROUTER_STATE_TREE]: JSON.stringify(flightRouterState)\n        };\n        if (prefetch) {\n            // Enable prefetch response\n            headers[_appRouterHeaders.NEXT_ROUTER_PREFETCH] = \"1\";\n        }\n        const res = yield fetch(url.toString(), {\n            headers\n        });\n        const canonicalUrl = res.redirected ? urlToUrlWithoutFlightMarker(res.url) : undefined;\n        const isFlightResponse = res.headers.get(\"content-type\") === \"application/octet-stream\";\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        if (!isFlightResponse) {\n            return [\n                res.url,\n                undefined\n            ];\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const flightData = yield (0, _client).createFromFetch(Promise.resolve(res));\n        return [\n            flightData,\n            canonicalUrl\n        ];\n    });\n    return _fetchServerResponse.apply(this, arguments);\n}\n// Ensure the initialParallelRoutes are not combined because of double-rendering in the browser with Strict Mode.\n// TODO-APP: move this back into AppRouter\nlet initialParallelRoutes =  false ? 0 : new Map();\nconst prefetched = new Set();\n/**\n * The global router that wraps the application components.\n */ function Router(param) {\n    let { initialHead , initialTree , initialCanonicalUrl , children , assetPrefix  } = param;\n    _s();\n    const initialState = (0, _react).useMemo(()=>{\n        return {\n            tree: initialTree,\n            cache: {\n                status: _appRouterContext.CacheStates.READY,\n                data: null,\n                subTreeData: children,\n                parallelRoutes:  false ? 0 : initialParallelRoutes\n            },\n            prefetchCache: new Map(),\n            pushRef: {\n                pendingPush: false,\n                mpaNavigation: false\n            },\n            focusAndScrollRef: {\n                apply: false\n            },\n            canonicalUrl: // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n             true ? (0, _reducer).createHrefFromUrl(new URL(window.location.href)) : 0\n        };\n    }, [\n        children,\n        initialCanonicalUrl,\n        initialTree\n    ]);\n    const [{ tree , cache , prefetchCache , pushRef , focusAndScrollRef , canonicalUrl  }, dispatch, sync] = (0, _useReducerWithDevtools).useReducerWithReduxDevtools(_reducer.reducer, initialState);\n    (0, _react).useEffect(()=>{\n        // Ensure initialParallelRoutes is cleaned up from memory once it's used.\n        initialParallelRoutes = null;\n    }, []);\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams , pathname  } = (0, _react).useMemo(()=>{\n        const url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    /**\n   * Server response that only patches the cache and tree.\n   */ const changeByServerResponse = (0, _react).useCallback((previousTree, flightData, overrideCanonicalUrl)=>{\n        dispatch({\n            type: _reducer.ACTION_SERVER_PATCH,\n            flightData,\n            previousTree,\n            overrideCanonicalUrl,\n            cache: {\n                status: _appRouterContext.CacheStates.LAZYINITIALIZED,\n                data: null,\n                subTreeData: null,\n                parallelRoutes: new Map()\n            },\n            mutable: {}\n        });\n    }, [\n        dispatch\n    ]);\n    /**\n   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.\n   */ const appRouter = (0, _react).useMemo(()=>{\n        const navigate = (href, navigateType, forceOptimisticNavigation)=>{\n            return dispatch({\n                type: _reducer.ACTION_NAVIGATE,\n                url: new URL(href, location.origin),\n                forceOptimisticNavigation,\n                navigateType,\n                cache: {\n                    status: _appRouterContext.CacheStates.LAZYINITIALIZED,\n                    data: null,\n                    subTreeData: null,\n                    parallelRoutes: new Map()\n                },\n                mutable: {}\n            });\n        };\n        const routerInstance = {\n            back: ()=>window.history.back(),\n            forward: ()=>window.history.forward(),\n            // TODO-APP: implement prefetching of flight\n            prefetch: _async_to_generator(function*(href) {\n                // If prefetch has already been triggered, don't trigger it again.\n                if (prefetched.has(href)) {\n                    return;\n                }\n                prefetched.add(href);\n                const url = new URL(href, location.origin);\n                try {\n                    var ref;\n                    const routerTree = ((ref = window.history.state) == null ? void 0 : ref.tree) || initialTree;\n                    // TODO-APP: handle case where history.state is not the new router history entry\n                    const serverResponse = yield fetchServerResponse(url, routerTree, true);\n                    // @ts-ignore startTransition exists\n                    _react.default.startTransition(()=>{\n                        dispatch({\n                            type: _reducer.ACTION_PREFETCH,\n                            url,\n                            tree: routerTree,\n                            serverResponse\n                        });\n                    });\n                } catch (err) {\n                    console.error(\"PREFETCH ERROR\", err);\n                }\n            }),\n            replace: function(href) {\n                let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    navigate(href, \"replace\", Boolean(options.forceOptimisticNavigation));\n                });\n            },\n            push: function(href) {\n                let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    navigate(href, \"push\", Boolean(options.forceOptimisticNavigation));\n                });\n            },\n            refresh: ()=>{\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    dispatch({\n                        type: _reducer.ACTION_REFRESH,\n                        // TODO-APP: revisit if this needs to be passed.\n                        cache: {\n                            status: _appRouterContext.CacheStates.LAZYINITIALIZED,\n                            data: null,\n                            subTreeData: null,\n                            parallelRoutes: new Map()\n                        },\n                        mutable: {}\n                    });\n                });\n            }\n        };\n        return routerInstance;\n    }, [\n        dispatch,\n        initialTree\n    ]);\n    (0, _react).useEffect(()=>{\n        // When mpaNavigation flag is set do a hard navigation to the new url.\n        if (pushRef.mpaNavigation) {\n            window.location.href = canonicalUrl;\n            return;\n        }\n        // Identifier is shortened intentionally.\n        // __NA is used to identify if the history entry can be handled by the app-router.\n        // __N is used to identify if the history entry can be handled by the old router.\n        const historyState = {\n            __NA: true,\n            tree\n        };\n        if (pushRef.pendingPush && (0, _reducer).createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, \"\", canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, \"\", canonicalUrl);\n        }\n        sync();\n    }, [\n        tree,\n        pushRef,\n        canonicalUrl,\n        sync\n    ]);\n    // Add `window.nd` for debugging purposes.\n    // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n    if (true) {\n        // @ts-ignore this is for debugging\n        window.nd = {\n            router: appRouter,\n            cache,\n            prefetchCache,\n            tree\n        };\n    }\n    /**\n   * Handle popstate event, this is used to handle back/forward in the browser.\n   * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n   * That case can happen when the old router injected the history entry.\n   */ const onPopState = (0, _react).useCallback((param)=>{\n        let { state  } = param;\n        if (!state) {\n            // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n            return;\n        }\n        // TODO-APP: this case happens when pushState/replaceState was called outside of Next.js or when the history entry was pushed by the old router.\n        // It reloads the page in this case but we might have to revisit this as the old router ignores it.\n        if (!state.__NA) {\n            window.location.reload();\n            return;\n        }\n        // @ts-ignore useTransition exists\n        // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n        // Without startTransition works if the cache is there for this path\n        _react.default.startTransition(()=>{\n            dispatch({\n                type: _reducer.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                tree: state.tree\n            });\n        });\n    }, [\n        dispatch\n    ]);\n    // Register popstate event to call onPopstate.\n    (0, _react).useEffect(()=>{\n        window.addEventListener(\"popstate\", onPopState);\n        return ()=>{\n            window.removeEventListener(\"popstate\", onPopState);\n        };\n    }, [\n        onPopState\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(_hooksClientContext.PathnameContext.Provider, {\n        value: pathname\n    }, /*#__PURE__*/ _react.default.createElement(_hooksClientContext.SearchParamsContext.Provider, {\n        value: searchParams\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.GlobalLayoutRouterContext.Provider, {\n        value: {\n            changeByServerResponse,\n            tree,\n            focusAndScrollRef\n        }\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.AppRouterContext.Provider, {\n        value: appRouter\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.LayoutRouterContext.Provider, {\n        value: {\n            childNodes: cache.parallelRoutes,\n            tree: tree,\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl\n        }\n    }, HotReloader ? /*#__PURE__*/ _react.default.createElement(HotReloader, {\n        assetPrefix: assetPrefix\n    }, initialHead, cache.subTreeData) : /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, initialHead, cache.subTreeData))))));\n}\n_s(Router, \"yWCtvIH/OEoTmoHU249b5/prOjk=\");\n_c1 = Router;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"AppRouter\");\n$RefreshReg$(_c1, \"Router\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtOGRmMmFlZGM0Ny8wL2NhY2hlL25leHQtbnBtLTEzLjAuMy1mYjg3YTE0MjRhLWYxZjZlOGE1NzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILDJCQUEyQixHQUFHSTtBQUM5QixJQUFJQyxzQkFBc0JDLHVNQUEwRDtBQUNwRixJQUFJQyw0QkFBNEJELG1OQUFnRTtBQUNoRyxJQUFJRSxTQUFTRCwwQkFBMEJELG1CQUFPQSxDQUFDLDJKQUFPO0FBQ3RELElBQUlHLFVBQVVILG1CQUFPQSxDQUFDLDROQUFvRDtBQUMxRSxJQUFJSSxvQkFBb0JKLG1CQUFPQSxDQUFDLGtNQUFxQztBQUNyRSxJQUFJSyxXQUFXTCxtQkFBT0EsQ0FBQyxvS0FBVztBQUNsQyxJQUFJTSxzQkFBc0JOLG1CQUFPQSxDQUFDLHNNQUF1QztBQUN6RSxJQUFJTywwQkFBMEJQLG1CQUFPQSxDQUFDLHdNQUE2QjtBQUNuRSxJQUFJUSxpQkFBaUJSLG1CQUFPQSxDQUFDLGtMQUFrQjtBQUMvQyxJQUFJUyxvQkFBb0JULG1CQUFPQSxDQUFDLDBMQUFzQjtBQUN0RCxTQUFTSCxVQUFVYSxLQUFLLEVBQUU7SUFDdEIsT0FBTyxXQUFXLEdBQUdSLE9BQU9OLE9BQU8sQ0FBQ2UsYUFBYSxDQUFDSCxlQUFlSSxhQUFhLEVBQUU7UUFDNUVDLGdCQUFnQkwsZUFBZU0sb0JBQW9CO0lBQ3ZELEdBQUcsV0FBVyxHQUFHWixPQUFPTixPQUFPLENBQUNlLGFBQWEsQ0FBQ0ksUUFBUXZCLE9BQU93QixNQUFNLENBQUMsQ0FBQyxHQUFHTjtBQUM1RTtLQUpTYjtBQUtUO0FBQ0EsU0FBU29CLDRCQUE0QkMsR0FBRyxFQUFFO0lBQ3RD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QWFRLE1BQU1LLFdBQVcsQ0FBQztBQUNsSjtHQWxQYWxEO01BQUFBO0FBb1BiLElBQUksQ0FBQyxPQUFPckIsUUFBUUUsT0FBTyxLQUFLLGNBQWUsT0FBT0YsUUFBUUUsT0FBTyxLQUFLLFlBQVlGLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDMkksVUFBVSxLQUFLLGFBQWE7SUFDcksvSSxPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPd0IsTUFBTSxDQUFDdEIsUUFBUUUsT0FBTyxFQUFFRjtJQUMvQjhJLE9BQU85SSxPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtOGRmMmFlZGM0Ny8wL2NhY2hlL25leHQtbnBtLTEzLjAuMy1mYjg3YTE0MjRhLWYxZjZlOGE1NzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qcz8wYzNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBcHBSb3V0ZXI7XG5leHBvcnRzLmZldGNoU2VydmVyUmVzcG9uc2UgPSBmZXRjaFNlcnZlclJlc3BvbnNlO1xudmFyIF9hc3luY190b19nZW5lcmF0b3IgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fYXN5bmNfdG9fZ2VuZXJhdG9yLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2NsaWVudCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudFwiKTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfcmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJcIik7XG52YXIgX2hvb2tzQ2xpZW50Q29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0XCIpO1xudmFyIF91c2VSZWR1Y2VyV2l0aERldnRvb2xzID0gcmVxdWlyZShcIi4vdXNlLXJlZHVjZXItd2l0aC1kZXZ0b29sc1wiKTtcbnZhciBfZXJyb3JCb3VuZGFyeSA9IHJlcXVpcmUoXCIuL2Vycm9yLWJvdW5kYXJ5XCIpO1xudmFyIF9hcHBSb3V0ZXJIZWFkZXJzID0gcmVxdWlyZShcIi4vYXBwLXJvdXRlci1oZWFkZXJzXCIpO1xuZnVuY3Rpb24gQXBwUm91dGVyKHByb3BzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfZXJyb3JCb3VuZGFyeS5FcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIGVycm9yQ29tcG9uZW50OiBfZXJyb3JCb3VuZGFyeS5HbG9iYWxFcnJvckNvbXBvbmVudFxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSb3V0ZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSkpO1xufVxuJ3VzZSBjbGllbnQnO1xuZnVuY3Rpb24gdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKHVybCkge1xuICAgIGNvbnN0IHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbik7XG4gICAgLy8gVE9ETy1BUFA6IGhhbmRsZSAucnNjIGZvciBzdGF0aWMgZXhwb3J0IGNhc2VcbiAgICByZXR1cm4gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnM7XG59XG5jb25zdCBIb3RSZWxvYWRlciA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyBudWxsIDogcmVxdWlyZSgnLi9yZWFjdC1kZXYtb3ZlcmxheS9ob3QtcmVsb2FkZXItY2xpZW50JykuZGVmYXVsdDtcbmZ1bmN0aW9uIGZldGNoU2VydmVyUmVzcG9uc2UodXJsLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgcHJlZmV0Y2gpIHtcbiAgICByZXR1cm4gX2ZldGNoU2VydmVyUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9mZXRjaFNlcnZlclJlc3BvbnNlKCkge1xuICAgIF9mZXRjaFNlcnZlclJlc3BvbnNlID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioodXJsLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgcHJlZmV0Y2gpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC8vIEVuYWJsZSBmbGlnaHQgcmVzcG9uc2VcbiAgICAgICAgICAgIFtfYXBwUm91dGVySGVhZGVycy5SU0NdOiAnMScsXG4gICAgICAgICAgICAvLyBQcm92aWRlIHRoZSBjdXJyZW50IHJvdXRlciBzdGF0ZVxuICAgICAgICAgICAgW19hcHBSb3V0ZXJIZWFkZXJzLk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVdOiBKU09OLnN0cmluZ2lmeShmbGlnaHRSb3V0ZXJTdGF0ZSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByZWZldGNoKSB7XG4gICAgICAgICAgICAvLyBFbmFibGUgcHJlZmV0Y2ggcmVzcG9uc2VcbiAgICAgICAgICAgIGhlYWRlcnNbX2FwcFJvdXRlckhlYWRlcnMuTkVYVF9ST1VURVJfUFJFRkVUQ0hdID0gJzEnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYW5vbmljYWxVcmwgPSByZXMucmVkaXJlY3RlZCA/IHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcihyZXMudXJsKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaXNGbGlnaHRSZXNwb25zZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICAvLyBJZiBmZXRjaCByZXR1cm5zIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBmbGlnaHQgcmVzcG9uc2UgaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgICAgICBpZiAoIWlzRmxpZ2h0UmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcmVzLnVybCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBgZmV0Y2hgIHJlYWRhYmxlIHN0cmVhbSB0aGF0IGNhbiBiZSB1bndyYXBwZWQgYnkgYFJlYWN0LnVzZWAuXG4gICAgICAgIGNvbnN0IGZsaWdodERhdGEgPSB5aWVsZCAoMCwgX2NsaWVudCkuY3JlYXRlRnJvbUZldGNoKFByb21pc2UucmVzb2x2ZShyZXMpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgICBjYW5vbmljYWxVcmxcbiAgICAgICAgXTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2ZldGNoU2VydmVyUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIEVuc3VyZSB0aGUgaW5pdGlhbFBhcmFsbGVsUm91dGVzIGFyZSBub3QgY29tYmluZWQgYmVjYXVzZSBvZiBkb3VibGUtcmVuZGVyaW5nIGluIHRoZSBicm93c2VyIHdpdGggU3RyaWN0IE1vZGUuXG4vLyBUT0RPLUFQUDogbW92ZSB0aGlzIGJhY2sgaW50byBBcHBSb3V0ZXJcbmxldCBpbml0aWFsUGFyYWxsZWxSb3V0ZXMgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBuZXcgTWFwKCk7XG5jb25zdCBwcmVmZXRjaGVkID0gbmV3IFNldCgpO1xuLyoqXG4gKiBUaGUgZ2xvYmFsIHJvdXRlciB0aGF0IHdyYXBzIHRoZSBhcHBsaWNhdGlvbiBjb21wb25lbnRzLlxuICovIGZ1bmN0aW9uIFJvdXRlcih7IGluaXRpYWxIZWFkICwgaW5pdGlhbFRyZWUgLCBpbml0aWFsQ2Fub25pY2FsVXJsICwgY2hpbGRyZW4gLCBhc3NldFByZWZpeCAgfSkge1xuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PntcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyZWU6IGluaXRpYWxUcmVlLFxuICAgICAgICAgICAgY2FjaGU6IHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IGNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG5ldyBNYXAoKSA6IGluaXRpYWxQYXJhbGxlbFJvdXRlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUHVzaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbm9uaWNhbFVybDogLy8gbG9jYXRpb24uaHJlZiBpcyByZWFkIGFzIHRoZSBpbml0aWFsIHZhbHVlIGZvciBjYW5vbmljYWxVcmwgaW4gdGhlIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgc2FmZSB0byBkbyBhcyBjYW5vbmljYWxVcmwgY2FuJ3QgYmUgcmVuZGVyZWQsIGl0J3Mgb25seSB1c2VkIHRvIGNvbnRyb2wgdGhlIGhpc3RvcnkgdXBkYXRlcyBpbiB0aGUgdXNlRWZmZWN0IGZ1cnRoZXIgZG93biBpbiB0aGlzIGZpbGUuXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/ICgwLCBfcmVkdWNlcikuY3JlYXRlSHJlZkZyb21VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikpIDogaW5pdGlhbENhbm9uaWNhbFVybFxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGluaXRpYWxDYW5vbmljYWxVcmwsXG4gICAgICAgIGluaXRpYWxUcmVlXG4gICAgXSk7XG4gICAgY29uc3QgW3sgdHJlZSAsIGNhY2hlICwgcHJlZmV0Y2hDYWNoZSAsIHB1c2hSZWYgLCBmb2N1c0FuZFNjcm9sbFJlZiAsIGNhbm9uaWNhbFVybCAgfSwgZGlzcGF0Y2gsIHN5bmMsIF0gPSAoMCwgX3VzZVJlZHVjZXJXaXRoRGV2dG9vbHMpLnVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyhfcmVkdWNlci5yZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBFbnN1cmUgaW5pdGlhbFBhcmFsbGVsUm91dGVzIGlzIGNsZWFuZWQgdXAgZnJvbSBtZW1vcnkgb25jZSBpdCdzIHVzZWQuXG4gICAgICAgIGluaXRpYWxQYXJhbGxlbFJvdXRlcyA9IG51bGw7XG4gICAgfSwgW10pO1xuICAgIC8vIEFkZCBtZW1vaXplZCBwYXRobmFtZS9xdWVyeSBmb3IgdXNlU2VhcmNoUGFyYW1zIGFuZCB1c2VQYXRobmFtZS5cbiAgICBjb25zdCB7IHNlYXJjaFBhcmFtcyAsIHBhdGhuYW1lICB9ID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGNhbm9uaWNhbFVybCwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0dXJuZWQgaW50byBhIHJlYWRvbmx5IGNsYXNzIGluIGB1c2VTZWFyY2hQYXJhbXNgXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXM6IHVybC5zZWFyY2hQYXJhbXMsXG4gICAgICAgICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjYW5vbmljYWxVcmxcbiAgICBdKTtcbiAgICAvKipcbiAgICogU2VydmVyIHJlc3BvbnNlIHRoYXQgb25seSBwYXRjaGVzIHRoZSBjYWNoZSBhbmQgdHJlZS5cbiAgICovIGNvbnN0IGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygocHJldmlvdXNUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk9PntcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogX3JlZHVjZXIuQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgICBwcmV2aW91c1RyZWUsXG4gICAgICAgICAgICBvdmVycmlkZUNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXV0YWJsZToge31cbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBkaXNwYXRjaFxuICAgIF0pO1xuICAgIC8qKlxuICAgKiBUaGUgYXBwIHJvdXRlciB0aGF0IGlzIGV4cG9zZWQgdGhyb3VnaCBgdXNlUm91dGVyYC4gSXQncyBvbmx5IGNvbmNlcm5lZCB3aXRoIGRpc3BhdGNoaW5nIGFjdGlvbnMgdG8gdGhlIHJlZHVjZXIsIGRvZXMgbm90IGhvbGQgc3RhdGUuXG4gICAqLyBjb25zdCBhcHBSb3V0ZXIgPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIGNvbnN0IG5hdmlnYXRlID0gKGhyZWYsIG5hdmlnYXRlVHlwZSwgZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbik9PntcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogX3JlZHVjZXIuQUNUSU9OX05BVklHQVRFLFxuICAgICAgICAgICAgICAgIHVybDogbmV3IFVSTChocmVmLCBsb2NhdGlvbi5vcmlnaW4pLFxuICAgICAgICAgICAgICAgIGZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24sXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUeXBlLFxuICAgICAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuTEFaWUlOSVRJQUxJWkVELFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbXV0YWJsZToge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByb3V0ZXJJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgIGJhY2s6ICgpPT53aW5kb3cuaGlzdG9yeS5iYWNrKCksXG4gICAgICAgICAgICBmb3J3YXJkOiAoKT0+d2luZG93Lmhpc3RvcnkuZm9yd2FyZCgpLFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGltcGxlbWVudCBwcmVmZXRjaGluZyBvZiBmbGlnaHRcbiAgICAgICAgICAgIHByZWZldGNoOiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKihocmVmKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcHJlZmV0Y2ggaGFzIGFscmVhZHkgYmVlbiB0cmlnZ2VyZWQsIGRvbid0IHRyaWdnZXIgaXQgYWdhaW4uXG4gICAgICAgICAgICAgICAgaWYgKHByZWZldGNoZWQuaGFzKGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJlZmV0Y2hlZC5hZGQoaHJlZik7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChocmVmLCBsb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlclRyZWUgPSAoKHJlZiA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLnRyZWUpIHx8IGluaXRpYWxUcmVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogaGFuZGxlIGNhc2Ugd2hlcmUgaGlzdG9yeS5zdGF0ZSBpcyBub3QgdGhlIG5ldyByb3V0ZXIgaGlzdG9yeSBlbnRyeVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IHlpZWxkIGZldGNoU2VydmVyUmVzcG9uc2UodXJsLCAvLyBpbml0aWFsVHJlZSBpcyB1c2VkIHdoZW4gaGlzdG9yeS5zdGF0ZS50cmVlIGlzIG1pc3NpbmcgYmVjYXVzZSB0aGUgaGlzdG9yeSBzdGF0ZSBpcyBzZXQgaW4gYHVzZUVmZmVjdGAgYmVsb3csIGl0IGJlaW5nIG1pc3NpbmcgbWVhbnMgdGhpcyBpcyB0aGUgaHlkcmF0aW9uIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlclRyZWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX3JlZHVjZXIuQUNUSU9OX1BSRUZFVENILFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiByb3V0ZXJUcmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BSRUZFVENIIEVSUk9SJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJlcGxhY2U6IChocmVmLCBvcHRpb25zID0ge30pPT57XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlKGhyZWYsICdyZXBsYWNlJywgQm9vbGVhbihvcHRpb25zLmZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwdXNoOiAoaHJlZiwgb3B0aW9ucyA9IHt9KT0+e1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZShocmVmLCAncHVzaCcsIEJvb2xlYW4ob3B0aW9ucy5mb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmcmVzaDogKCk9PntcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX3JlZHVjZXIuQUNUSU9OX1JFRlJFU0gsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogcmV2aXNpdCBpZiB0aGlzIG5lZWRzIHRvIGJlIHBhc3NlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZToge31cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3V0ZXJJbnN0YW5jZTtcbiAgICB9LCBbXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBpbml0aWFsVHJlZVxuICAgIF0pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBXaGVuIG1wYU5hdmlnYXRpb24gZmxhZyBpcyBzZXQgZG8gYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIG5ldyB1cmwuXG4gICAgICAgIGlmIChwdXNoUmVmLm1wYU5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gY2Fub25pY2FsVXJsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElkZW50aWZpZXIgaXMgc2hvcnRlbmVkIGludGVudGlvbmFsbHkuXG4gICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgICAgLy8gX19OIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIG9sZCByb3V0ZXIuXG4gICAgICAgIGNvbnN0IGhpc3RvcnlTdGF0ZSA9IHtcbiAgICAgICAgICAgIF9fTkE6IHRydWUsXG4gICAgICAgICAgICB0cmVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwdXNoUmVmLnBlbmRpbmdQdXNoICYmICgwLCBfcmVkdWNlcikuY3JlYXRlSHJlZkZyb21VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikpICE9PSBjYW5vbmljYWxVcmwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaW50ZW50aW9uYWxseSBtdXRhdGVzIFJlYWN0IHN0YXRlLCBwdXNoUmVmIGlzIG92ZXJ3cml0dGVuIHRvIGVuc3VyZSBhZGRpdGlvbmFsIHB1c2gvcmVwbGFjZSBjYWxscyBkbyBub3QgdHJpZ2dlciBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkuXG4gICAgICAgICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoID0gZmFsc2U7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmMoKTtcbiAgICB9LCBbXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHB1c2hSZWYsXG4gICAgICAgIGNhbm9uaWNhbFVybCxcbiAgICAgICAgc3luY1xuICAgIF0pO1xuICAgIC8vIEFkZCBgd2luZG93Lm5kYCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgIC8vIFRoaXMgaXMgbm90IG1lYW50IGZvciB1c2UgaW4gYXBwbGljYXRpb25zIGFzIGNvbmN1cnJlbnQgcmVuZGVyaW5nIHdpbGwgYWZmZWN0IHRoZSBjYWNoZS90cmVlL3JvdXRlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgd2luZG93Lm5kID0ge1xuICAgICAgICAgICAgcm91dGVyOiBhcHBSb3V0ZXIsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICB0cmVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgKiBIYW5kbGUgcG9wc3RhdGUgZXZlbnQsIHRoaXMgaXMgdXNlZCB0byBoYW5kbGUgYmFjay9mb3J3YXJkIGluIHRoZSBicm93c2VyLlxuICAgKiBCeSBkZWZhdWx0IGRpc3BhdGNoZXMgQUNUSU9OX1JFU1RPUkUsIGhvd2V2ZXIgaWYgdGhlIGhpc3RvcnkgZW50cnkgd2FzIG5vdCBwdXNoZWQvcmVwbGFjZWQgYnkgYXBwLXJvdXRlciBpdCB3aWxsIHJlbG9hZCB0aGUgcGFnZS5cbiAgICogVGhhdCBjYXNlIGNhbiBoYXBwZW4gd2hlbiB0aGUgb2xkIHJvdXRlciBpbmplY3RlZCB0aGUgaGlzdG9yeSBlbnRyeS5cbiAgICovIGNvbnN0IG9uUG9wU3RhdGUgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoeyBzdGF0ZSAgfSk9PntcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHRoaXMgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBOZXh0LmpzLiBJdCBzaG91bGQgcHJvYmFibHkgcmVsb2FkIHRoZSBwYWdlIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPLUFQUDogdGhpcyBjYXNlIGhhcHBlbnMgd2hlbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBOZXh0LmpzIG9yIHdoZW4gdGhlIGhpc3RvcnkgZW50cnkgd2FzIHB1c2hlZCBieSB0aGUgb2xkIHJvdXRlci5cbiAgICAgICAgLy8gSXQgcmVsb2FkcyB0aGUgcGFnZSBpbiB0aGlzIGNhc2UgYnV0IHdlIG1pZ2h0IGhhdmUgdG8gcmV2aXNpdCB0aGlzIGFzIHRoZSBvbGQgcm91dGVyIGlnbm9yZXMgaXQuXG4gICAgICAgIGlmICghc3RhdGUuX19OQSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgdXNlVHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgLy8gVE9ETy1BUFA6IElkZWFsbHkgdGhlIGJhY2sgYnV0dG9uIHNob3VsZCBub3QgdXNlIHN0YXJ0VHJhbnNpdGlvbiBhcyBpdCBzaG91bGQgYXBwbHkgdGhlIHVwZGF0ZXMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBXaXRob3V0IHN0YXJ0VHJhbnNpdGlvbiB3b3JrcyBpZiB0aGUgY2FjaGUgaXMgdGhlcmUgZm9yIHRoaXMgcGF0aFxuICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBfcmVkdWNlci5BQ1RJT05fUkVTVE9SRSxcbiAgICAgICAgICAgICAgICB1cmw6IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLFxuICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGRpc3BhdGNoXG4gICAgXSk7XG4gICAgLy8gUmVnaXN0ZXIgcG9wc3RhdGUgZXZlbnQgdG8gY2FsbCBvblBvcHN0YXRlLlxuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG9uUG9wU3RhdGVcbiAgICBdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9ob29rc0NsaWVudENvbnRleHQuUGF0aG5hbWVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwYXRobmFtZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaG9va3NDbGllbnRDb250ZXh0LlNlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHNlYXJjaFBhcmFtc1xuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlLFxuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmXG4gICAgICAgIH1cbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcFJvdXRlckNvbnRleHQuQXBwUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogYXBwUm91dGVyXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNhY2hlLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgdHJlZTogdHJlZSxcbiAgICAgICAgICAgIC8vIFJvb3Qgbm9kZSBhbHdheXMgaGFzIGB1cmxgXG4gICAgICAgICAgICAvLyBQcm92aWRlZCBpbiBBcHBUcmVlQ29udGV4dCB0byBlbnN1cmUgaXQgY2FuIGJlIG92ZXJ3cml0dGVuIGluIGxheW91dC1yb3V0ZXJcbiAgICAgICAgICAgIHVybDogY2Fub25pY2FsVXJsXG4gICAgICAgIH1cbiAgICB9LCBIb3RSZWxvYWRlciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIb3RSZWxvYWRlciwge1xuICAgICAgICBhc3NldFByZWZpeDogYXNzZXRQcmVmaXhcbiAgICB9LCBpbml0aWFsSGVhZCwgY2FjaGUuc3ViVHJlZURhdGEpIDogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBpbml0aWFsSGVhZCwgY2FjaGUuc3ViVHJlZURhdGEpKSkpKSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIkFwcFJvdXRlciIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJfYXN5bmNfdG9fZ2VuZXJhdG9yIiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfcmVhY3QiLCJfY2xpZW50IiwiX2FwcFJvdXRlckNvbnRleHQiLCJfcmVkdWNlciIsIl9ob29rc0NsaWVudENvbnRleHQiLCJfdXNlUmVkdWNlcldpdGhEZXZ0b29scyIsIl9lcnJvckJvdW5kYXJ5IiwiX2FwcFJvdXRlckhlYWRlcnMiLCJwcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJHbG9iYWxFcnJvckNvbXBvbmVudCIsIlJvdXRlciIsImFzc2lnbiIsInVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlciIsInVybCIsInVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJIb3RSZWxvYWRlciIsInByb2Nlc3MiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInByZWZldGNoIiwiX2ZldGNoU2VydmVyUmVzcG9uc2UiLCJhcHBseSIsImFyZ3VtZW50cyIsImhlYWRlcnMiLCJSU0MiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFIiwiSlNPTiIsInN0cmluZ2lmeSIsIk5FWFRfUk9VVEVSX1BSRUZFVENIIiwicmVzIiwiZmV0Y2giLCJ0b1N0cmluZyIsImNhbm9uaWNhbFVybCIsInJlZGlyZWN0ZWQiLCJ1bmRlZmluZWQiLCJpc0ZsaWdodFJlc3BvbnNlIiwiZ2V0IiwiZmxpZ2h0RGF0YSIsImNyZWF0ZUZyb21GZXRjaCIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW5pdGlhbFBhcmFsbGVsUm91dGVzIiwiTWFwIiwicHJlZmV0Y2hlZCIsIlNldCIsImluaXRpYWxIZWFkIiwiaW5pdGlhbFRyZWUiLCJpbml0aWFsQ2Fub25pY2FsVXJsIiwiY2hpbGRyZW4iLCJhc3NldFByZWZpeCIsImluaXRpYWxTdGF0ZSIsInVzZU1lbW8iLCJ0cmVlIiwiY2FjaGUiLCJzdGF0dXMiLCJDYWNoZVN0YXRlcyIsIlJFQURZIiwiZGF0YSIsInN1YlRyZWVEYXRhIiwicGFyYWxsZWxSb3V0ZXMiLCJwcmVmZXRjaENhY2hlIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsImZvY3VzQW5kU2Nyb2xsUmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ3aW5kb3ciLCJocmVmIiwiZGlzcGF0Y2giLCJzeW5jIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzIiwicmVkdWNlciIsInVzZUVmZmVjdCIsInNlYXJjaFBhcmFtcyIsInBhdGhuYW1lIiwiY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSIsInVzZUNhbGxiYWNrIiwicHJldmlvdXNUcmVlIiwib3ZlcnJpZGVDYW5vbmljYWxVcmwiLCJ0eXBlIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsIkxBWllJTklUSUFMSVpFRCIsIm11dGFibGUiLCJhcHBSb3V0ZXIiLCJuYXZpZ2F0ZSIsIm5hdmlnYXRlVHlwZSIsImZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24iLCJBQ1RJT05fTkFWSUdBVEUiLCJyb3V0ZXJJbnN0YW5jZSIsImJhY2siLCJoaXN0b3J5IiwiZm9yd2FyZCIsImhhcyIsImFkZCIsInJlZiIsInJvdXRlclRyZWUiLCJzdGF0ZSIsInNlcnZlclJlc3BvbnNlIiwic3RhcnRUcmFuc2l0aW9uIiwiQUNUSU9OX1BSRUZFVENIIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwicmVwbGFjZSIsIm9wdGlvbnMiLCJCb29sZWFuIiwicHVzaCIsInJlZnJlc2giLCJBQ1RJT05fUkVGUkVTSCIsImhpc3RvcnlTdGF0ZSIsIl9fTkEiLCJwdXNoU3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJuZCIsInJvdXRlciIsIm9uUG9wU3RhdGUiLCJyZWxvYWQiLCJBQ1RJT05fUkVTVE9SRSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiUGF0aG5hbWVDb250ZXh0IiwiUHJvdmlkZXIiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIkFwcFJvdXRlckNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiY2hpbGROb2RlcyIsIkZyYWdtZW50IiwiX19lc01vZHVsZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/error-boundary.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/error-boundary.js ***!
  \****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ErrorBoundary = ErrorBoundary;\nexports.GlobalErrorComponent = GlobalErrorComponent;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/compiled/react/index.js\"));\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */ class ErrorBoundaryHandler extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    render() {\n        if (this.state.error) {\n            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, this.props.errorStyles, /*#__PURE__*/ _react.default.createElement(this.props.errorComponent, {\n                error: this.state.error,\n                reset: this.reset\n            }));\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.reset = ()=>{\n            this.setState({\n                error: null\n            });\n        };\n        this.state = {\n            error: null\n        };\n    }\n}\nfunction ErrorBoundary(param) {\n    let { errorComponent , errorStyles , children  } = param;\n    if (errorComponent) {\n        return /*#__PURE__*/ _react.default.createElement(ErrorBoundaryHandler, {\n            errorComponent: errorComponent,\n            errorStyles: errorStyles\n        }, children);\n    }\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_c = ErrorBoundary;\nconst styles = {\n    error: {\n        fontFamily: '-apple-system, BlinkMacSystemFont, Roboto, \"Segoe UI\", \"Fira Sans\", Avenir, \"Helvetica Neue\", \"Lucida Grande\", sans-serif',\n        height: \"100vh\",\n        textAlign: \"center\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        justifyContent: \"center\"\n    },\n    desc: {\n        display: \"inline-block\",\n        textAlign: \"left\",\n        lineHeight: \"49px\",\n        height: \"49px\",\n        verticalAlign: \"middle\"\n    },\n    h2: {\n        fontSize: \"14px\",\n        fontWeight: \"normal\",\n        lineHeight: \"49px\",\n        margin: 0,\n        padding: 0\n    }\n};\nfunction GlobalErrorComponent() {\n    return /*#__PURE__*/ _react.default.createElement(\"html\", null, /*#__PURE__*/ _react.default.createElement(\"body\", null, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        style: styles.error\n    }, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        style: styles.desc\n    }, /*#__PURE__*/ _react.default.createElement(\"h2\", {\n        style: styles.h2\n    }, \"Application error: a client-side exception has occurred (see the browser console for more information).\")))));\n}\n_c1 = GlobalErrorComponent;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"ErrorBoundary\");\n$RefreshReg$(_c1, \"GlobalErrorComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtOGRmMmFlZGM0Ny8wL2NhY2hlL25leHQtbnBtLTEzLjAuMy1mYjg3YTE0MjRhLWYxZjZlOGE1NzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnkuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQscUJBQXFCLEdBQUdFO0FBQ3hCRiw0QkFBNEIsR0FBR0c7QUFDL0IsSUFBSUMsMkJBQTJCQyxpTkFBK0Q7QUFDOUYsSUFBSUUsU0FBU0gseUJBQXlCQyxtQkFBT0EsQ0FBQywySkFBTztBQUNyRDs7O0NBR0MsR0FBRyxNQUFNRyw2QkFBNkJELE9BQU9ELE9BQU8sQ0FBQ0csU0FBUztJQUMzRCxPQUFPQyx5QkFBeUJDLEtBQUssRUFBRTtRQUNuQyxPQUFPO1lBQ0hBO1FBQ0o7SUFDSjtJQUNBQyxTQUFTO1FBQ0wsSUFBSSxJQUFJLENBQUNDLEtBQUssQ0FBQ0YsS0FBSyxFQUFFO1lBQ2xCLE9BQU8sV0FBVyxHQUFHSixPQUFPRCxPQUFPLENBQUNRLGFBQWEsQ0FBQ1AsT0FBT0QsT0FBTyxDQUFDUyxRQUFRLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxXQUFXLEVBQUUsV0FBVyxHQUFHVixPQUFPRCxPQUFPLENBQUNRLGFBQWEsQ0FBQyxJQUFJLENBQUNFLEtBQUssQ0FBQ0UsY0FBYyxFQUFFO2dCQUMzS1AsT0FBTyxJQUFJLENBQUNFLEtBQUssQ0FBQ0YsS0FBSztnQkFDdkJRLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQ3JCO1FBQ0osQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDSCxLQUFLLENBQUNJLFFBQVE7SUFDOUI7SUFDQUMsWUFBWUwsS0FBSyxDQUFDO1FBQ2QsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0csS0FBSyxHQUFHLElBQUk7WUFDYixJQUFJLENBQUNHLFFBQVEsQ0FBQztnQkFDVlgsT0FBTyxJQUFJO1lBQ2Y7UUFDSjtRQUNBLElBQUksQ0FBQ0UsS0FBSyxHQUFHO1lBQ1RGLE9BQU8sSUFBSTtRQUNmO0lBQ0o7QUFDSjtBQUNBLFNBQVNULGNBQWMsS0FBNEMsRUFBRTtRQUE5QyxFQUFFZ0IsZUFBYyxFQUFHRCxZQUFXLEVBQUdHLFNBQVEsRUFBRyxHQUE1QztJQUNuQixJQUFJRixnQkFBZ0I7UUFDaEIsT0FBTyxXQUFXLEdBQUdYLE9BQU9ELE9BQU8sQ0FBQ1EsYUFBYSxDQUFDTixzQkFBc0I7WUFDcEVVLGdCQUFnQkE7WUFDaEJELGFBQWFBO1FBQ2pCLEdBQUdHO0lBQ1AsQ0FBQztJQUNELE9BQU8sV0FBVyxHQUFHYixPQUFPRCxPQUFPLENBQUNRLGFBQWEsQ0FBQ1AsT0FBT0QsT0FBTyxDQUFDUyxRQUFRLEVBQUUsSUFBSSxFQUFFSztBQUNyRjtLQVJTbEI7QUFTVCxNQUFNcUIsU0FBUztJQUNYWixPQUFPO1FBQ0hhLFlBQVk7UUFDWkMsUUFBUTtRQUNSQyxXQUFXO1FBQ1hDLFNBQVM7UUFDVEMsZUFBZTtRQUNmQyxZQUFZO1FBQ1pDLGdCQUFnQjtJQUNwQjtJQUNBQyxNQUFNO1FBQ0ZKLFNBQVM7UUFDVEQsV0FBVztRQUNYTSxZQUFZO1FBQ1pQLFFBQVE7UUFDUlEsZUFBZTtJQUNuQjtJQUNBQyxJQUFJO1FBQ0FDLFVBQVU7UUFDVkMsWUFBWTtRQUNaSixZQUFZO1FBQ1pLLFFBQVE7UUFDUkMsU0FBUztJQUNiO0FBQ0o7QUFDQSxTQUFTbkMsdUJBQXVCO0lBQzVCLE9BQU8sV0FBVyxHQUFHSSxPQUFPRCxPQUFPLENBQUNRLGFBQWEsQ0FBQyxRQUFRLElBQUksRUFBRSxXQUFXLEdBQUdQLE9BQU9ELE9BQU8sQ0FBQ1EsYUFBYSxDQUFDLFFBQVEsSUFBSSxFQUFFLFdBQVcsR0FBR1AsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUMsT0FBTztRQUN2S3lCLE9BQU9oQixPQUFPWixLQUFLO0lBQ3ZCLEdBQUcsV0FBVyxHQUFHSixPQUFPRCxPQUFPLENBQUNRLGFBQWEsQ0FBQyxPQUFPO1FBQ2pEeUIsT0FBT2hCLE9BQU9RLElBQUk7SUFDdEIsR0FBRyxXQUFXLEdBQUd4QixPQUFPRCxPQUFPLENBQUNRLGFBQWEsQ0FBQyxNQUFNO1FBQ2hEeUIsT0FBT2hCLE9BQU9XLEVBQUU7SUFDcEIsR0FBRztBQUNQO01BUlMvQjtBQVVULElBQUksQ0FBQyxPQUFPSCxRQUFRTSxPQUFPLEtBQUssY0FBZSxPQUFPTixRQUFRTSxPQUFPLEtBQUssWUFBWU4sUUFBUU0sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTixRQUFRTSxPQUFPLENBQUNrQyxVQUFVLEtBQUssYUFBYTtJQUNySzFDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU0sT0FBTyxFQUFFLGNBQWM7UUFBRUwsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU8yQyxNQUFNLENBQUN6QyxRQUFRTSxPQUFPLEVBQUVOO0lBQy9CMEMsT0FBTzFDLE9BQU8sR0FBR0EsUUFBUU0sT0FBTztBQUNsQyxDQUFDLENBRUQsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC04ZGYyYWVkYzQ3LzAvY2FjaGUvbmV4dC1ucG0tMTMuMC4zLWZiODdhMTQyNGEtZjFmNmU4YTU3NC56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9lcnJvci1ib3VuZGFyeS5qcz9iYTBkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcbmV4cG9ydHMuR2xvYmFsRXJyb3JDb21wb25lbnQgPSBHbG9iYWxFcnJvckNvbXBvbmVudDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbi8qKlxuICogSGFuZGxlcyBlcnJvcnMgdGhyb3VnaCBgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yYC5cbiAqIFJlbmRlcnMgdGhlIHByb3ZpZGVkIGVycm9yIGNvbXBvbmVudCBhbmQgcHJvdmlkZXMgYSB3YXkgdG8gYHJlc2V0YCB0aGUgZXJyb3IgYm91bmRhcnkgc3RhdGUuXG4gKi8gY2xhc3MgRXJyb3JCb3VuZGFyeUhhbmRsZXIgZXh0ZW5kcyBfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIHRoaXMucHJvcHMuZXJyb3JTdHlsZXMsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudCh0aGlzLnByb3BzLmVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVzZXQ6IHRoaXMucmVzZXRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMucmVzZXQgPSAoKT0+e1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBFcnJvckJvdW5kYXJ5KHsgZXJyb3JDb21wb25lbnQgLCBlcnJvclN0eWxlcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgaWYgKGVycm9yQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeUhhbmRsZXIsIHtcbiAgICAgICAgICAgIGVycm9yQ29tcG9uZW50OiBlcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIGVycm9yU3R5bGVzOiBlcnJvclN0eWxlc1xuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbmNvbnN0IHN0eWxlcyA9IHtcbiAgICBlcnJvcjoge1xuICAgICAgICBmb250RmFtaWx5OiAnLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBSb2JvdG8sIFwiU2Vnb2UgVUlcIiwgXCJGaXJhIFNhbnNcIiwgQXZlbmlyLCBcIkhlbHZldGljYSBOZXVlXCIsIFwiTHVjaWRhIEdyYW5kZVwiLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInXG4gICAgfSxcbiAgICBkZXNjOiB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgICAgbGluZUhlaWdodDogJzQ5cHgnLFxuICAgICAgICBoZWlnaHQ6ICc0OXB4JyxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICB9LFxuICAgIGgyOiB7XG4gICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICBsaW5lSGVpZ2h0OiAnNDlweCcsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH1cbn07XG5mdW5jdGlvbiBHbG9iYWxFcnJvckNvbXBvbmVudCgpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZXMuZXJyb3JcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLmRlc2NcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZXMuaDJcbiAgICB9LCBcIkFwcGxpY2F0aW9uIGVycm9yOiBhIGNsaWVudC1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQgKHNlZSB0aGUgYnJvd3NlciBjb25zb2xlIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cIikpKSkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci1ib3VuZGFyeS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJFcnJvckJvdW5kYXJ5IiwiR2xvYmFsRXJyb3JDb21wb25lbnQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9yZWFjdCIsIkVycm9yQm91bmRhcnlIYW5kbGVyIiwiQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZXJyb3IiLCJyZW5kZXIiLCJzdGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsInByb3BzIiwiZXJyb3JTdHlsZXMiLCJlcnJvckNvbXBvbmVudCIsInJlc2V0IiwiY2hpbGRyZW4iLCJjb25zdHJ1Y3RvciIsInNldFN0YXRlIiwic3R5bGVzIiwiZm9udEZhbWlseSIsImhlaWdodCIsInRleHRBbGlnbiIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwiZGVzYyIsImxpbmVIZWlnaHQiLCJ2ZXJ0aWNhbEFsaWduIiwiaDIiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJtYXJnaW4iLCJwYWRkaW5nIiwic3R5bGUiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/error-boundary.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/infinite-promise.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/infinite-promise.js ***!
  \******************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createInfinitePromise = createInfinitePromise;\n/**\n * Used to cache in createInfinitePromise\n */ let infinitePromise;\nfunction createInfinitePromise() {\n    if (!infinitePromise) {\n        // Only create the Promise once\n        infinitePromise = new Promise(()=>{\n        // This is used to debug when the rendering is never updated.\n        // setTimeout(() => {\n        //   infinitePromise = new Error('Infinite promise')\n        //   resolve()\n        // }, 5000)\n        });\n    }\n    return infinitePromise;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=infinite-promise.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtOGRmMmFlZGM0Ny8wL2NhY2hlL25leHQtbnBtLTEzLjAuMy1mYjg3YTE0MjRhLWYxZjZlOGE1NzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaW5maW5pdGUtcHJvbWlzZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCw2QkFBNkIsR0FBR0U7QUFDaEM7O0NBRUMsR0FBRyxJQUFJQztBQUNSLFNBQVNELHdCQUF3QjtJQUM3QixJQUFJLENBQUNDLGlCQUFpQjtRQUNsQiwrQkFBK0I7UUFDL0JBLGtCQUFrQixJQUFJQyxRQUFRLElBQUk7UUFDbEMsNkRBQTZEO1FBQzdELHFCQUFxQjtRQUNyQixvREFBb0Q7UUFDcEQsY0FBYztRQUNkLFdBQVc7UUFDWDtJQUNKLENBQUM7SUFDRCxPQUFPRDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9ILFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktSLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9TLE1BQU0sQ0FBQ1AsUUFBUUssT0FBTyxFQUFFTDtJQUMvQlEsT0FBT1IsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLThkZjJhZWRjNDcvMC9jYWNoZS9uZXh0LW5wbS0xMy4wLjMtZmI4N2ExNDI0YS1mMWY2ZThhNTc0LnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2luZmluaXRlLXByb21pc2UuanM/YjAzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlSW5maW5pdGVQcm9taXNlID0gY3JlYXRlSW5maW5pdGVQcm9taXNlO1xuLyoqXG4gKiBVc2VkIHRvIGNhY2hlIGluIGNyZWF0ZUluZmluaXRlUHJvbWlzZVxuICovIGxldCBpbmZpbml0ZVByb21pc2U7XG5mdW5jdGlvbiBjcmVhdGVJbmZpbml0ZVByb21pc2UoKSB7XG4gICAgaWYgKCFpbmZpbml0ZVByb21pc2UpIHtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgdGhlIFByb21pc2Ugb25jZVxuICAgICAgICBpbmZpbml0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gZGVidWcgd2hlbiB0aGUgcmVuZGVyaW5nIGlzIG5ldmVyIHVwZGF0ZWQuXG4gICAgICAgIC8vIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyAgIGluZmluaXRlUHJvbWlzZSA9IG5ldyBFcnJvcignSW5maW5pdGUgcHJvbWlzZScpXG4gICAgICAgIC8vICAgcmVzb2x2ZSgpXG4gICAgICAgIC8vIH0sIDUwMDApXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5maW5pdGVQcm9taXNlO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZpbml0ZS1wcm9taXNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUluZmluaXRlUHJvbWlzZSIsImluZmluaXRlUHJvbWlzZSIsIlByb21pc2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/infinite-promise.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/layout-router.js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/layout-router.js ***!
  \***************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = OuterLayoutRouter;\nexports.InnerLayoutRouter = InnerLayoutRouter;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/compiled/react/index.js\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _appRouter = __webpack_require__(/*! ./app-router */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/app-router.js\");\nvar _infinitePromise = __webpack_require__(/*! ./infinite-promise */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/infinite-promise.js\");\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/error-boundary.js\");\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/match-segments.js\");\nvar _navigation = __webpack_require__(/*! ./navigation */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/navigation.js\");\nfunction OuterLayoutRouter(param) {\n    let { parallelRouterKey , segmentPath , childProp , error , errorStyles , templateStyles , loading , loadingStyles , hasLoading , template , notFound , notFoundStyles , rootLayoutIncluded  } = param;\n    _s();\n    const context = (0, _react).useContext(_appRouterContext.LayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant expected layout router to be mounted\");\n    }\n    const { childNodes , tree , url  } = context;\n    // Get the current parallelRouter cache node\n    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodes.set(parallelRouterKey, new Map());\n        childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    const treeSegment = tree[1][parallelRouterKey][0];\n    const childPropSegment = Array.isArray(childProp.segment) ? childProp.segment[1] : childProp.segment;\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    const currentChildSegment = Array.isArray(treeSegment) ? treeSegment[1] : treeSegment;\n    /**\n   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    const preservedSegments = [\n        currentChildSegment\n    ];\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, preservedSegments.map((preservedSegment)=>{\n        return(/*\n            - Error boundary\n              - Only renders error boundary if error component is provided.\n              - Rendered for each segment to ensure they have their own error state.\n            - Loading boundary\n              - Only renders suspense boundary if loading components is provided.\n              - Rendered for each segment to ensure they have their own loading state.\n              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n          */ /*#__PURE__*/ _react.default.createElement(_appRouterContext.TemplateContext.Provider, {\n            key: preservedSegment,\n            value: /*#__PURE__*/ _react.default.createElement(_errorBoundary.ErrorBoundary, {\n                errorComponent: error,\n                errorStyles: errorStyles\n            }, /*#__PURE__*/ _react.default.createElement(LoadingBoundary, {\n                hasLoading: hasLoading,\n                loading: loading,\n                loadingStyles: loadingStyles\n            }, /*#__PURE__*/ _react.default.createElement(NotFoundBoundary, {\n                notFound: notFound,\n                notFoundStyles: notFoundStyles\n            }, /*#__PURE__*/ _react.default.createElement(RedirectBoundary, null, /*#__PURE__*/ _react.default.createElement(InnerLayoutRouter, {\n                parallelRouterKey: parallelRouterKey,\n                url: url,\n                tree: tree,\n                childNodes: childNodesForParallelRouter,\n                childProp: childPropSegment === preservedSegment ? childProp : null,\n                segmentPath: segmentPath,\n                path: preservedSegment,\n                isActive: currentChildSegment === preservedSegment,\n                rootLayoutIncluded: rootLayoutIncluded\n            })))))\n        }, /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, templateStyles, template)));\n    }));\n}\n_s(OuterLayoutRouter, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n_c = OuterLayoutRouter;\n\"use client\";\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchSegments).matchSegment(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        _extends({}, treeToRecreate[1], {\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                \"refetch\"\n                            ]\n                        })\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    _extends({}, treeToRecreate[1], {\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    })\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\n/**\n * Check if the top of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0;\n}\nfunction InnerLayoutRouter(param) {\n    let { parallelRouterKey , url , childNodes , childProp , segmentPath , tree , // isActive,\n    path , rootLayoutIncluded  } = param;\n    _s1();\n    const context = (0, _react).useContext(_appRouterContext.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    const { changeByServerResponse , tree: fullTree , focusAndScrollRef  } = context;\n    const focusAndScrollElementRef = (0, _react).useRef(null);\n    (0, _react).useEffect(()=>{\n        // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n        if (focusAndScrollRef.apply && focusAndScrollElementRef.current) {\n            // State is mutated to ensure that the focus and scroll is applied only once.\n            focusAndScrollRef.apply = false;\n            // Set focus on the element\n            focusAndScrollElementRef.current.focus();\n            // Only scroll into viewport when the layout is not visible currently.\n            if (!topOfElementInViewport(focusAndScrollElementRef.current)) {\n                const htmlElement = document.documentElement;\n                const existing = htmlElement.style.scrollBehavior;\n                htmlElement.style.scrollBehavior = \"auto\";\n                focusAndScrollElementRef.current.scrollIntoView();\n                htmlElement.style.scrollBehavior = existing;\n            }\n        }\n    }, [\n        focusAndScrollRef\n    ]);\n    // Read segment path from the parallel router cache node.\n    let childNode = childNodes.get(path);\n    // If childProp is available this means it's the Flight / SSR case.\n    if (childProp && // TODO-APP: verify if this can be null based on user code\n    childProp.current !== null) {\n        if (childNode && childNode.status === _appRouterContext.CacheStates.LAZYINITIALIZED) {\n            // @ts-expect-error TODO-APP: handle changing of the type\n            childNode.status = _appRouterContext.CacheStates.READY;\n            // @ts-expect-error TODO-APP: handle changing of the type\n            childNode.subTreeData = childProp.current;\n            // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n            childProp.current = null;\n        } else {\n            // Add the segment's subTreeData to the cache.\n            // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n            childNodes.set(path, {\n                status: _appRouterContext.CacheStates.READY,\n                data: null,\n                subTreeData: childProp.current,\n                parallelRoutes: new Map()\n            });\n            // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n            childProp.current = null;\n            // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n            childNode = childNodes.get(path);\n        }\n    }\n    // When childNode is not available during rendering client-side we need to fetch it from the server.\n    if (!childNode) {\n        /**\n     * Router state with refetch marker added\n     */ // TODO-APP: remove ''\n        const refetchTree = walkAddRefetch([\n            \"\",\n            ...segmentPath\n        ], fullTree);\n        /**\n     * Flight data fetch kicked off during render and put into the cache.\n     */ childNodes.set(path, {\n            status: _appRouterContext.CacheStates.DATAFETCH,\n            data: (0, _appRouter).fetchServerResponse(new URL(url, location.origin), refetchTree),\n            subTreeData: null,\n            parallelRoutes: new Map()\n        });\n        // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n        childNode = childNodes.get(path);\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (!childNode) {\n        throw new Error(\"Child node should always exist\");\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (childNode.subTreeData && childNode.data) {\n        throw new Error(\"Child node should not have both subTreeData and data\");\n    }\n    // If cache node has a data request we have to unwrap response by `use` and update the cache.\n    if (childNode.data) {\n        // TODO-APP: error case\n        /**\n     * Flight response data\n     */ // When the data has not resolved yet `use` will suspend here.\n        const [flightData, overrideCanonicalUrl] = (0, _react).use(childNode.data);\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            window.location.href = url;\n            return null;\n        }\n        // segmentPath from the server does not match the layout's segmentPath\n        childNode.data = null;\n        // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n        setTimeout(()=>{\n            // @ts-ignore startTransition exists\n            _react.default.startTransition(()=>{\n                // TODO-APP: handle redirect\n                changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);\n            });\n        });\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        (0, _react).use((0, _infinitePromise).createInfinitePromise());\n    }\n    // If cache node has no subTreeData and no data request we have to infinitely suspend as the data will likely flow in from another place.\n    // TODO-APP: double check users can't return null in a component that will kick in here.\n    if (!childNode.subTreeData) {\n        (0, _react).use((0, _infinitePromise).createInfinitePromise());\n    }\n    const subtree = /*#__PURE__*/ _react.default.createElement(_appRouterContext.LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url\n        }\n    }, childNode.subTreeData);\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return rootLayoutIncluded ? /*#__PURE__*/ _react.default.createElement(\"div\", {\n        ref: focusAndScrollElementRef,\n        \"data-nextjs-scroll-focus-boundary\": \"\"\n    }, subtree) : subtree;\n}\n_s1(InnerLayoutRouter, \"JQanpc2hF1A904pZOh54fuThoYw=\");\n_c1 = InnerLayoutRouter;\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary(param) {\n    let { children , loading , loadingStyles , hasLoading  } = param;\n    if (hasLoading) {\n        return /*#__PURE__*/ _react.default.createElement(_react.default.Suspense, {\n            fallback: /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, loadingStyles, loading)\n        }, children);\n    }\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_c2 = LoadingBoundary;\nfunction HandleRedirect(param) {\n    let { redirect  } = param;\n    _s2();\n    const router = (0, _navigation).useRouter();\n    (0, _react).useEffect(()=>{\n        router.replace(redirect, {});\n    }, [\n        redirect,\n        router\n    ]);\n    return null;\n}\n_s2(HandleRedirect, \"vQduR7x+OPXj6PSmJyFnf+hU7bg=\");\n_c3 = HandleRedirect;\nclass RedirectErrorBoundary extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        var ref;\n        if ((ref = error.digest) == null ? void 0 : ref.startsWith(\"NEXT_REDIRECT\")) {\n            const url = error.digest.split(\";\")[1];\n            return {\n                redirect: url\n            };\n        }\n        // Re-throw if error is not for redirect\n        throw error;\n    }\n    render() {\n        const redirect = this.state.redirect;\n        if (redirect !== null) {\n            return /*#__PURE__*/ _react.default.createElement(HandleRedirect, {\n                redirect: redirect\n            });\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            redirect: null\n        };\n    }\n}\nfunction RedirectBoundary(param) {\n    let { children  } = param;\n    _s3();\n    const router = (0, _navigation).useRouter();\n    return /*#__PURE__*/ _react.default.createElement(RedirectErrorBoundary, {\n        router: router\n    }, children);\n}\n_s3(RedirectBoundary, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\");\n_c4 = RedirectBoundary;\nclass NotFoundErrorBoundary extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        if (error.digest === \"NEXT_NOT_FOUND\") {\n            return {\n                notFoundTriggered: true\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    render() {\n        if (this.state.notFoundTriggered) {\n            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"meta\", {\n                name: \"robots\",\n                content: \"noindex\"\n            }), this.props.notFoundStyles, this.props.notFound);\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            notFoundTriggered: false\n        };\n    }\n}\nfunction NotFoundBoundary(param) {\n    let { notFound , notFoundStyles , children  } = param;\n    return notFound ? /*#__PURE__*/ _react.default.createElement(NotFoundErrorBoundary, {\n        notFound: notFound,\n        notFoundStyles: notFoundStyles\n    }, children) : /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_c5 = NotFoundBoundary;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=layout-router.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"OuterLayoutRouter\");\n$RefreshReg$(_c1, \"InnerLayoutRouter\");\n$RefreshReg$(_c2, \"LoadingBoundary\");\n$RefreshReg$(_c3, \"HandleRedirect\");\n$RefreshReg$(_c4, \"RedirectBoundary\");\n$RefreshReg$(_c5, \"NotFoundBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtOGRmMmFlZGM0Ny8wL2NhY2hlL25leHQtbnBtLTEzLjAuMy1mYjg3YTE0MjRhLWYxZjZlOGE1NzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILHlCQUF5QixHQUFHSTtBQUM1QixJQUFJQyxXQUFXQyxpTEFBK0M7QUFDOUQsSUFBSUMsNEJBQTRCRCxtTkFBZ0U7QUFDaEcsSUFBSUUsU0FBU0QsMEJBQTBCRCxtQkFBT0EsQ0FBQywySkFBTztBQUN0RCxJQUFJRyxvQkFBb0JILG1CQUFPQSxDQUFDLGtNQUFxQztBQUNyRSxJQUFJSSxhQUFhSixtQkFBT0EsQ0FBQywwS0FBYztBQUN2QyxJQUFJSyxtQkFBbUJMLG1CQUFPQSxDQUFDLHNMQUFvQjtBQUNuRCxJQUFJTSxpQkFBaUJOLG1CQUFPQSxDQUFDLGtMQUFrQjtBQUMvQyxJQUFJTyxpQkFBaUJQLG1CQUFPQSxDQUFDLGtMQUFrQjtBQUMvQyxJQUFJUSxjQUFjUixtQkFBT0EsQ0FBQywwS0FBYztBQUN4QyxTQUFTSCxrQkFBa0IsS0FBMEwsRUFBRTtRQUE1TCxFQUFFWSxrQkFBaUIsRUFBR0MsWUFBVyxFQUFHQyxVQUFTLEVBQUdDLE1BQUssRUFBR0MsWUFBVyxFQUFHQyxlQUFjLEVBQUdDLFFBQU8sRUFBR0MsY0FBYSxFQUFHQyxXQUFVLEVBQUdDLFNBQVEsRUFBR0MsU0FBUSxFQUFHQyxlQUFjLEVBQUdDLG1CQUFrQixFQUFHLEdBQTFMOztJQUN2QixNQUFNQyxVQUFVLENBQUMsR0FBR3BCLE1BQU0sRUFBRXFCLFVBQVUsQ0FBQ3BCLGtCQUFrQnFCLG1CQUFtQjtJQUM1RSxJQUFJLENBQUNGLFNBQVM7UUFDVixNQUFNLElB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RSxPQUFPLEVBQUUsY0FBYztRQUFFRCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTzhJLE1BQU0sQ0FBQzVJLFFBQVFFLE9BQU8sRUFBRUY7SUFDL0I2SSxPQUFPN0ksT0FBTyxHQUFHQSxRQUFRRSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLThkZjJhZWRjNDcvMC9jYWNoZS9uZXh0LW5wbS0xMy4wLjMtZmI4N2ExNDI0YS1mMWY2ZThhNTc0LnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanM/NmFhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gT3V0ZXJMYXlvdXRSb3V0ZXI7XG5leHBvcnRzLklubmVyTGF5b3V0Um91dGVyID0gSW5uZXJMYXlvdXRSb3V0ZXI7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xudmFyIF9hcHBSb3V0ZXIgPSByZXF1aXJlKFwiLi9hcHAtcm91dGVyXCIpO1xudmFyIF9pbmZpbml0ZVByb21pc2UgPSByZXF1aXJlKFwiLi9pbmZpbml0ZS1wcm9taXNlXCIpO1xudmFyIF9lcnJvckJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vZXJyb3ItYm91bmRhcnlcIik7XG52YXIgX21hdGNoU2VnbWVudHMgPSByZXF1aXJlKFwiLi9tYXRjaC1zZWdtZW50c1wiKTtcbnZhciBfbmF2aWdhdGlvbiA9IHJlcXVpcmUoXCIuL25hdmlnYXRpb25cIik7XG5mdW5jdGlvbiBPdXRlckxheW91dFJvdXRlcih7IHBhcmFsbGVsUm91dGVyS2V5ICwgc2VnbWVudFBhdGggLCBjaGlsZFByb3AgLCBlcnJvciAsIGVycm9yU3R5bGVzICwgdGVtcGxhdGVTdHlsZXMgLCBsb2FkaW5nICwgbG9hZGluZ1N0eWxlcyAsIGhhc0xvYWRpbmcgLCB0ZW1wbGF0ZSAsIG5vdEZvdW5kICwgbm90Rm91bmRTdHlsZXMgLCByb290TGF5b3V0SW5jbHVkZWQgIH0pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5MYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZXhwZWN0ZWQgbGF5b3V0IHJvdXRlciB0byBiZSBtb3VudGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2hpbGROb2RlcyAsIHRyZWUgLCB1cmwgIH0gPSBjb250ZXh0O1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBwYXJhbGxlbFJvdXRlciBjYWNoZSBub2RlXG4gICAgbGV0IGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciA9IGNoaWxkTm9kZXMuZ2V0KHBhcmFsbGVsUm91dGVyS2V5KTtcbiAgICAvLyBJZiB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuXG4gICAgLy8gVGhpcyB3cml0ZXMgdG8gdGhlIGNhY2hlIHdoZW4gdGhlcmUgaXMgbm8gaXRlbSBpbiB0aGUgY2FjaGUgeWV0LiBJdCBuZXZlciAqb3ZlcndyaXRlcyogZXhpc3RpbmcgY2FjaGUgaXRlbXMgd2hpY2ggaXMgd2h5IGl0J3Mgc2FmZSBpbiBjb25jdXJyZW50IG1vZGUuXG4gICAgaWYgKCFjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5zZXQocGFyYWxsZWxSb3V0ZXJLZXksIG5ldyBNYXAoKSk7XG4gICAgICAgIGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciA9IGNoaWxkTm9kZXMuZ2V0KHBhcmFsbGVsUm91dGVyS2V5KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBhY3RpdmUgc2VnbWVudCBpbiB0aGUgdHJlZVxuICAgIC8vIFRoZSByZWFzb24gYXJyYXlzIGFyZSB1c2VkIGluIHRoZSBkYXRhIGZvcm1hdCBpcyB0aGF0IHRoZXNlIGFyZSB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGJyb3dzZXIgc28gaXQncyBvcHRpbWl6ZWQgdG8gc2F2ZSBieXRlcy5cbiAgICBjb25zdCB0cmVlU2VnbWVudCA9IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldWzBdO1xuICAgIGNvbnN0IGNoaWxkUHJvcFNlZ21lbnQgPSBBcnJheS5pc0FycmF5KGNoaWxkUHJvcC5zZWdtZW50KSA/IGNoaWxkUHJvcC5zZWdtZW50WzFdIDogY2hpbGRQcm9wLnNlZ21lbnQ7XG4gICAgLy8gSWYgc2VnbWVudCBpcyBhbiBhcnJheSBpdCdzIGEgZHluYW1pYyByb3V0ZSBhbmQgd2Ugd2FudCB0byByZWFkIHRoZSBkeW5hbWljIHJvdXRlIHZhbHVlIGFzIHRoZSBzZWdtZW50IHRvIGdldCBmcm9tIHRoZSBjYWNoZS5cbiAgICBjb25zdCBjdXJyZW50Q2hpbGRTZWdtZW50ID0gQXJyYXkuaXNBcnJheSh0cmVlU2VnbWVudCkgPyB0cmVlU2VnbWVudFsxXSA6IHRyZWVTZWdtZW50O1xuICAgIC8qKlxuICAgKiBEZWNpZGVzIHdoaWNoIHNlZ21lbnRzIHRvIGtlZXAgcmVuZGVyaW5nLCBhbGwgc2VnbWVudHMgdGhhdCBhcmUgbm90IGFjdGl2ZSB3aWxsIGJlIHdyYXBwZWQgaW4gYDxPZmZzY3JlZW4+YC5cbiAgICovIC8vIFRPRE8tQVBQOiBBZGQgaGFuZGxpbmcgb2YgYDxPZmZzY3JlZW4+YCB3aGVuIGl0J3MgYXZhaWxhYmxlLlxuICAgIGNvbnN0IHByZXNlcnZlZFNlZ21lbnRzID0gW1xuICAgICAgICBjdXJyZW50Q2hpbGRTZWdtZW50XG4gICAgXTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBwcmVzZXJ2ZWRTZWdtZW50cy5tYXAoKHByZXNlcnZlZFNlZ21lbnQpPT57XG4gICAgICAgIHJldHVybigvKlxuICAgICAgICAgICAgLSBFcnJvciBib3VuZGFyeVxuICAgICAgICAgICAgICAtIE9ubHkgcmVuZGVycyBlcnJvciBib3VuZGFyeSBpZiBlcnJvciBjb21wb25lbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC0gUmVuZGVyZWQgZm9yIGVhY2ggc2VnbWVudCB0byBlbnN1cmUgdGhleSBoYXZlIHRoZWlyIG93biBlcnJvciBzdGF0ZS5cbiAgICAgICAgICAgIC0gTG9hZGluZyBib3VuZGFyeVxuICAgICAgICAgICAgICAtIE9ubHkgcmVuZGVycyBzdXNwZW5zZSBib3VuZGFyeSBpZiBsb2FkaW5nIGNvbXBvbmVudHMgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC0gUmVuZGVyZWQgZm9yIGVhY2ggc2VnbWVudCB0byBlbnN1cmUgdGhleSBoYXZlIHRoZWlyIG93biBsb2FkaW5nIHN0YXRlLlxuICAgICAgICAgICAgICAtIFBhc3NlZCB0byB0aGUgcm91dGVyIGR1cmluZyByZW5kZXJpbmcgdG8gZW5zdXJlIGl0IGNhbiBiZSBpbW1lZGlhdGVseSByZW5kZXJlZCB3aGVuIHN1c3BlbmRpbmcgb24gYSBGbGlnaHQgZmV0Y2guXG4gICAgICAgICAgKi8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LlRlbXBsYXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAga2V5OiBwcmVzZXJ2ZWRTZWdtZW50LFxuICAgICAgICAgICAgdmFsdWU6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfZXJyb3JCb3VuZGFyeS5FcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgZXJyb3JDb21wb25lbnQ6IGVycm9yLFxuICAgICAgICAgICAgICAgIGVycm9yU3R5bGVzOiBlcnJvclN0eWxlc1xuICAgICAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KExvYWRpbmdCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgIGhhc0xvYWRpbmc6IGhhc0xvYWRpbmcsXG4gICAgICAgICAgICAgICAgbG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgICAgICAgICBsb2FkaW5nU3R5bGVzOiBsb2FkaW5nU3R5bGVzXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTm90Rm91bmRCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgIG5vdEZvdW5kOiBub3RGb3VuZCxcbiAgICAgICAgICAgICAgICBub3RGb3VuZFN0eWxlczogbm90Rm91bmRTdHlsZXNcbiAgICAgICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSZWRpcmVjdEJvdW5kYXJ5LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSW5uZXJMYXlvdXRSb3V0ZXIsIHtcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlcktleTogcGFyYWxsZWxSb3V0ZXJLZXksXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgdHJlZTogdHJlZSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIsXG4gICAgICAgICAgICAgICAgY2hpbGRQcm9wOiBjaGlsZFByb3BTZWdtZW50ID09PSBwcmVzZXJ2ZWRTZWdtZW50ID8gY2hpbGRQcm9wIDogbnVsbCxcbiAgICAgICAgICAgICAgICBzZWdtZW50UGF0aDogc2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgcGF0aDogcHJlc2VydmVkU2VnbWVudCxcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogY3VycmVudENoaWxkU2VnbWVudCA9PT0gcHJlc2VydmVkU2VnbWVudCxcbiAgICAgICAgICAgICAgICByb290TGF5b3V0SW5jbHVkZWQ6IHJvb3RMYXlvdXRJbmNsdWRlZFxuICAgICAgICAgICAgfSkpKSkpXG4gICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgdGVtcGxhdGVTdHlsZXMsIHRlbXBsYXRlKSkpO1xuICAgIH0pKTtcbn1cbid1c2UgY2xpZW50Jztcbi8qKlxuICogQWRkIHJlZmV0Y2ggbWFya2VyIHRvIHJvdXRlciBzdGF0ZSBhdCB0aGUgcG9pbnQgb2YgdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKiBUaGlzIGVuc3VyZXMgdGhlIHJlc3BvbnNlIHJldHVybmVkIGlzIG5vdCBmdXJ0aGVyIGRvd24gdGhhbiB0aGUgY3VycmVudCBsYXlvdXQgc2VnbWVudC5cbiAqLyBmdW5jdGlvbiB3YWxrQWRkUmVmZXRjaChzZWdtZW50UGF0aFRvV2FsaywgdHJlZVRvUmVjcmVhdGUpIHtcbiAgICBpZiAoc2VnbWVudFBhdGhUb1dhbGspIHtcbiAgICAgICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXldID0gc2VnbWVudFBhdGhUb1dhbGs7XG4gICAgICAgIGNvbnN0IGlzTGFzdCA9IHNlZ21lbnRQYXRoVG9XYWxrLmxlbmd0aCA9PT0gMjtcbiAgICAgICAgaWYgKCgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KHRyZWVUb1JlY3JlYXRlWzBdLCBzZWdtZW50KSkge1xuICAgICAgICAgICAgaWYgKHRyZWVUb1JlY3JlYXRlWzFdLmhhc093blByb3BlcnR5KHBhcmFsbGVsUm91dGVLZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJUcmVlID0gd2Fsa0FkZFJlZmV0Y2godW5kZWZpbmVkLCB0cmVlVG9SZWNyZWF0ZVsxXVtwYXJhbGxlbFJvdXRlS2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlVG9SZWNyZWF0ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9leHRlbmRzKHt9LCB0cmVlVG9SZWNyZWF0ZVsxXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVmZXRjaCcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdHJlZVRvUmVjcmVhdGVbMF0sXG4gICAgICAgICAgICAgICAgICAgIF9leHRlbmRzKHt9LCB0cmVlVG9SZWNyZWF0ZVsxXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3BhcmFsbGVsUm91dGVLZXldOiB3YWxrQWRkUmVmZXRjaChzZWdtZW50UGF0aFRvV2Fsay5zbGljZSgyKSwgdHJlZVRvUmVjcmVhdGVbMV1bcGFyYWxsZWxSb3V0ZUtleV0pXG4gICAgICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmVlVG9SZWNyZWF0ZTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRvcCBvZiB0aGUgSFRNTEVsZW1lbnQgaXMgaW4gdGhlIHZpZXdwb3J0LlxuICovIGZ1bmN0aW9uIHRvcE9mRWxlbWVudEluVmlld3BvcnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiByZWN0LnRvcCA+PSAwO1xufVxuZnVuY3Rpb24gSW5uZXJMYXlvdXRSb3V0ZXIoeyBwYXJhbGxlbFJvdXRlcktleSAsIHVybCAsIGNoaWxkTm9kZXMgLCBjaGlsZFByb3AgLCBzZWdtZW50UGF0aCAsIHRyZWUgLCAvLyBUT0RPLUFQUDogaW1wbGVtZW50IGA8T2Zmc2NyZWVuPmAgd2hlbiBhdmFpbGFibGUuXG4vLyBpc0FjdGl2ZSxcbnBhdGggLCByb290TGF5b3V0SW5jbHVkZWQgIH0pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZ2xvYmFsIGxheW91dCByb3V0ZXIgbm90IG1vdW50ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlICwgdHJlZTogZnVsbFRyZWUgLCBmb2N1c0FuZFNjcm9sbFJlZiAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgZm9jdXNBbmRTY3JvbGxFbGVtZW50UmVmID0gKDAsIF9yZWFjdCkudXNlUmVmKG51bGwpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBIYW5kbGUgc2Nyb2xsIGFuZCBmb2N1cywgaXQncyBvbmx5IGFwcGxpZWQgb25jZSBpbiB0aGUgZmlyc3QgdXNlRWZmZWN0IHRoYXQgdHJpZ2dlcnMgdGhhdCBjaGFuZ2VkLlxuICAgICAgICBpZiAoZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkgJiYgZm9jdXNBbmRTY3JvbGxFbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIFN0YXRlIGlzIG11dGF0ZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGZvY3VzIGFuZCBzY3JvbGwgaXMgYXBwbGllZCBvbmx5IG9uY2UuXG4gICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZi5hcHBseSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gU2V0IGZvY3VzIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBmb2N1c0FuZFNjcm9sbEVsZW1lbnRSZWYuY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgICAgLy8gT25seSBzY3JvbGwgaW50byB2aWV3cG9ydCB3aGVuIHRoZSBsYXlvdXQgaXMgbm90IHZpc2libGUgY3VycmVudGx5LlxuICAgICAgICAgICAgaWYgKCF0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGZvY3VzQW5kU2Nyb2xsRWxlbWVudFJlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3I7XG4gICAgICAgICAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxFbGVtZW50UmVmLmN1cnJlbnQuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IGV4aXN0aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZlxuICAgIF0pO1xuICAgIC8vIFJlYWQgc2VnbWVudCBwYXRoIGZyb20gdGhlIHBhcmFsbGVsIHJvdXRlciBjYWNoZSBub2RlLlxuICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzLmdldChwYXRoKTtcbiAgICAvLyBJZiBjaGlsZFByb3AgaXMgYXZhaWxhYmxlIHRoaXMgbWVhbnMgaXQncyB0aGUgRmxpZ2h0IC8gU1NSIGNhc2UuXG4gICAgaWYgKGNoaWxkUHJvcCAmJiAvLyBUT0RPLUFQUDogdmVyaWZ5IGlmIHRoaXMgY2FuIGJlIG51bGwgYmFzZWQgb24gdXNlciBjb2RlXG4gICAgY2hpbGRQcm9wLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuc3RhdHVzID09PSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZSU5JVElBTElaRUQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETy1BUFA6IGhhbmRsZSBjaGFuZ2luZyBvZiB0aGUgdHlwZVxuICAgICAgICAgICAgY2hpbGROb2RlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPLUFQUDogaGFuZGxlIGNoYW5naW5nIG9mIHRoZSB0eXBlXG4gICAgICAgICAgICBjaGlsZE5vZGUuc3ViVHJlZURhdGEgPSBjaGlsZFByb3AuY3VycmVudDtcbiAgICAgICAgICAgIC8vIE11dGF0ZXMgdGhlIHByb3AgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhlIG1lbW9yeSBhc3NvY2lhdGVkIHdpdGggdGhlIHN1YlRyZWVEYXRhIGFzIGl0IGlzIG5vdyBwYXJ0IG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNoaWxkUHJvcC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgc2VnbWVudCdzIHN1YlRyZWVEYXRhIHRvIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgICAgICAgICAgY2hpbGROb2Rlcy5zZXQocGF0aCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFksXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRQcm9wLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBNdXRhdGVzIHRoZSBwcm9wIGluIG9yZGVyIHRvIGNsZWFuIHVwIHRoZSBtZW1vcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBzdWJUcmVlRGF0YSBhcyBpdCBpcyBub3cgcGFydCBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICBjaGlsZFByb3AuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBJbiB0aGUgYWJvdmUgY2FzZSBjaGlsZE5vZGUgd2FzIHNldCBvbiBjaGlsZE5vZGVzLCBzbyB3ZSBoYXZlIHRvIGdldCBpdCBmcm9tIHRoZSBjYWNoZU5vZGVzIGFnYWluLlxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2hlbiBjaGlsZE5vZGUgaXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgcmVuZGVyaW5nIGNsaWVudC1zaWRlIHdlIG5lZWQgdG8gZmV0Y2ggaXQgZnJvbSB0aGUgc2VydmVyLlxuICAgIGlmICghY2hpbGROb2RlKSB7XG4gICAgICAgIC8qKlxuICAgICAqIFJvdXRlciBzdGF0ZSB3aXRoIHJlZmV0Y2ggbWFya2VyIGFkZGVkXG4gICAgICovIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgY29uc3QgcmVmZXRjaFRyZWUgPSB3YWxrQWRkUmVmZXRjaChbXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIC4uLnNlZ21lbnRQYXRoXG4gICAgICAgIF0sIGZ1bGxUcmVlKTtcbiAgICAgICAgLyoqXG4gICAgICogRmxpZ2h0IGRhdGEgZmV0Y2gga2lja2VkIG9mZiBkdXJpbmcgcmVuZGVyIGFuZCBwdXQgaW50byB0aGUgY2FjaGUuXG4gICAgICovIGNoaWxkTm9kZXMuc2V0KHBhdGgsIHtcbiAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuREFUQUZFVENILFxuICAgICAgICAgICAgZGF0YTogKDAsIF9hcHBSb3V0ZXIpLmZldGNoU2VydmVyUmVzcG9uc2UobmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbiksIHJlZmV0Y2hUcmVlKSxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW4gdGhlIGFib3ZlIGNhc2UgY2hpbGROb2RlIHdhcyBzZXQgb24gY2hpbGROb2Rlcywgc28gd2UgaGF2ZSB0byBnZXQgaXQgZnJvbSB0aGUgY2FjaGVOb2RlcyBhZ2Fpbi5cbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQocGF0aCk7XG4gICAgfVxuICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuIHNvIGl0IHRocm93cyBhbiBlcnJvci4gSXQgaW5kaWNhdGVzIHRoZXJlJ3MgYSBidWcgaW4gdGhlIE5leHQuanMuXG4gICAgaWYgKCFjaGlsZE5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZCBub2RlIHNob3VsZCBhbHdheXMgZXhpc3QnKTtcbiAgICB9XG4gICAgLy8gVGhpcyBjYXNlIHNob3VsZCBuZXZlciBoYXBwZW4gc28gaXQgdGhyb3dzIGFuIGVycm9yLiBJdCBpbmRpY2F0ZXMgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgTmV4dC5qcy5cbiAgICBpZiAoY2hpbGROb2RlLnN1YlRyZWVEYXRhICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgbm9kZSBzaG91bGQgbm90IGhhdmUgYm90aCBzdWJUcmVlRGF0YSBhbmQgZGF0YScpO1xuICAgIH1cbiAgICAvLyBJZiBjYWNoZSBub2RlIGhhcyBhIGRhdGEgcmVxdWVzdCB3ZSBoYXZlIHRvIHVud3JhcCByZXNwb25zZSBieSBgdXNlYCBhbmQgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgICAgLy8gVE9ETy1BUFA6IGVycm9yIGNhc2VcbiAgICAgICAgLyoqXG4gICAgICogRmxpZ2h0IHJlc3BvbnNlIGRhdGFcbiAgICAgKi8gLy8gV2hlbiB0aGUgZGF0YSBoYXMgbm90IHJlc29sdmVkIHlldCBgdXNlYCB3aWxsIHN1c3BlbmQgaGVyZS5cbiAgICAgICAgY29uc3QgW2ZsaWdodERhdGEsIG92ZXJyaWRlQ2Fub25pY2FsVXJsXSA9ICgwLCBfcmVhY3QpLnVzZShjaGlsZE5vZGUuZGF0YSk7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlZ21lbnRQYXRoIGZyb20gdGhlIHNlcnZlciBkb2VzIG5vdCBtYXRjaCB0aGUgbGF5b3V0J3Mgc2VnbWVudFBhdGhcbiAgICAgICAgY2hpbGROb2RlLmRhdGEgPSBudWxsO1xuICAgICAgICAvLyBzZXRUaW1lb3V0IGlzIHVzZWQgdG8gc3RhcnQgYSBuZXcgdHJhbnNpdGlvbiBkdXJpbmcgcmVuZGVyLCB0aGlzIGlzIGFuIGludGVudGlvbmFsIGhhY2sgYXJvdW5kIFJlYWN0LlxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgcmVkaXJlY3RcbiAgICAgICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlKGZ1bGxUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN1c3BlbmQgaW5maW5pdGVseSBhcyBgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZWAgd2lsbCBjYXVzZSBhIGRpZmZlcmVudCBwYXJ0IG9mIHRoZSB0cmVlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAoMCwgX3JlYWN0KS51c2UoKDAsIF9pbmZpbml0ZVByb21pc2UpLmNyZWF0ZUluZmluaXRlUHJvbWlzZSgpKTtcbiAgICB9XG4gICAgLy8gSWYgY2FjaGUgbm9kZSBoYXMgbm8gc3ViVHJlZURhdGEgYW5kIG5vIGRhdGEgcmVxdWVzdCB3ZSBoYXZlIHRvIGluZmluaXRlbHkgc3VzcGVuZCBhcyB0aGUgZGF0YSB3aWxsIGxpa2VseSBmbG93IGluIGZyb20gYW5vdGhlciBwbGFjZS5cbiAgICAvLyBUT0RPLUFQUDogZG91YmxlIGNoZWNrIHVzZXJzIGNhbid0IHJldHVybiBudWxsIGluIGEgY29tcG9uZW50IHRoYXQgd2lsbCBraWNrIGluIGhlcmUuXG4gICAgaWYgKCFjaGlsZE5vZGUuc3ViVHJlZURhdGEpIHtcbiAgICAgICAgKDAsIF9yZWFjdCkudXNlKCgwLCBfaW5maW5pdGVQcm9taXNlKS5jcmVhdGVJbmZpbml0ZVByb21pc2UoKSk7XG4gICAgfVxuICAgIGNvbnN0IHN1YnRyZWUgPSAvLyBUaGUgbGF5b3V0IHJvdXRlciBjb250ZXh0IG5hcnJvd3MgZG93biB0cmVlIGFuZCBjaGlsZE5vZGVzIGF0IGVhY2ggbGV2ZWwuXG4gICAgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRyZWU6IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IG92ZXJyaWRpbmcgb2YgdXJsIGZvciBwYXJhbGxlbCByb3V0ZXNcbiAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgIH1cbiAgICB9LCBjaGlsZE5vZGUuc3ViVHJlZURhdGEpO1xuICAgIC8vIEVuc3VyZSByb290IGxheW91dCBpcyBub3Qgd3JhcHBlZCBpbiBhIGRpdiBhcyB0aGUgcm9vdCBsYXlvdXQgcmVuZGVycyBgPGh0bWw+YFxuICAgIHJldHVybiByb290TGF5b3V0SW5jbHVkZWQgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICByZWY6IGZvY3VzQW5kU2Nyb2xsRWxlbWVudFJlZixcbiAgICAgICAgXCJkYXRhLW5leHRqcy1zY3JvbGwtZm9jdXMtYm91bmRhcnlcIjogJydcbiAgICB9LCBzdWJ0cmVlKSA6IHN1YnRyZWU7XG59XG4vKipcbiAqIFJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgd2l0aCB0aGUgcHJvdmlkZWQgXCJsb2FkaW5nXCIgcHJvcGVydHkgYXMgdGhlIGZhbGxiYWNrLlxuICogSWYgbm8gbG9hZGluZyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBpdCByZW5kZXJzIHRoZSBjaGlsZHJlbiB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gKi8gZnVuY3Rpb24gTG9hZGluZ0JvdW5kYXJ5KHsgY2hpbGRyZW4gLCBsb2FkaW5nICwgbG9hZGluZ1N0eWxlcyAsIGhhc0xvYWRpbmcgIH0pIHtcbiAgICBpZiAoaGFzTG9hZGluZykge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN1c3BlbnNlLCB7XG4gICAgICAgICAgICBmYWxsYmFjazogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBsb2FkaW5nU3R5bGVzLCBsb2FkaW5nKVxuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIEhhbmRsZVJlZGlyZWN0KHsgcmVkaXJlY3QgIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICByb3V0ZXIucmVwbGFjZShyZWRpcmVjdCwge30pO1xuICAgIH0sIFtcbiAgICAgICAgcmVkaXJlY3QsXG4gICAgICAgIHJvdXRlclxuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuY2xhc3MgUmVkaXJlY3RFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGlmICgocmVmID0gZXJyb3IuZGlnZXN0KSA9PSBudWxsID8gdm9pZCAwIDogcmVmLnN0YXJ0c1dpdGgoJ05FWFRfUkVESVJFQ1QnKSkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZXJyb3IuZGlnZXN0LnNwbGl0KCc7JylbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiB1cmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciByZWRpcmVjdFxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCByZWRpcmVjdCA9IHRoaXMuc3RhdGUucmVkaXJlY3Q7XG4gICAgICAgIGlmIChyZWRpcmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIYW5kbGVSZWRpcmVjdCwge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiByZWRpcmVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcmVkaXJlY3Q6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBSZWRpcmVjdEJvdW5kYXJ5KHsgY2hpbGRyZW4gIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIHJvdXRlcjogcm91dGVyXG4gICAgfSwgY2hpbGRyZW4pO1xufVxuY2xhc3MgTm90Rm91bmRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5kaWdlc3QgPT09ICdORVhUX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm90Rm91bmRUcmlnZ2VyZWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubm90Rm91bmRUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwicm9ib3RzXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJub2luZGV4XCJcbiAgICAgICAgICAgIH0pLCB0aGlzLnByb3BzLm5vdEZvdW5kU3R5bGVzLCB0aGlzLnByb3BzLm5vdEZvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBub3RGb3VuZFRyaWdnZXJlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBOb3RGb3VuZEJvdW5kYXJ5KHsgbm90Rm91bmQgLCBub3RGb3VuZFN0eWxlcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgcmV0dXJuIG5vdEZvdW5kID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE5vdEZvdW5kRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBub3RGb3VuZDogbm90Rm91bmQsXG4gICAgICAgIG5vdEZvdW5kU3R5bGVzOiBub3RGb3VuZFN0eWxlc1xuICAgIH0sIGNoaWxkcmVuKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJPdXRlckxheW91dFJvdXRlciIsIklubmVyTGF5b3V0Um91dGVyIiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZWFjdCIsIl9hcHBSb3V0ZXJDb250ZXh0IiwiX2FwcFJvdXRlciIsIl9pbmZpbml0ZVByb21pc2UiLCJfZXJyb3JCb3VuZGFyeSIsIl9tYXRjaFNlZ21lbnRzIiwiX25hdmlnYXRpb24iLCJwYXJhbGxlbFJvdXRlcktleSIsInNlZ21lbnRQYXRoIiwiY2hpbGRQcm9wIiwiZXJyb3IiLCJlcnJvclN0eWxlcyIsInRlbXBsYXRlU3R5bGVzIiwibG9hZGluZyIsImxvYWRpbmdTdHlsZXMiLCJoYXNMb2FkaW5nIiwidGVtcGxhdGUiLCJub3RGb3VuZCIsIm5vdEZvdW5kU3R5bGVzIiwicm9vdExheW91dEluY2x1ZGVkIiwiY29udGV4dCIsInVzZUNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiRXJyb3IiLCJjaGlsZE5vZGVzIiwidHJlZSIsInVybCIsImNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciIsImdldCIsInNldCIsIk1hcCIsInRyZWVTZWdtZW50IiwiY2hpbGRQcm9wU2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsInNlZ21lbnQiLCJjdXJyZW50Q2hpbGRTZWdtZW50IiwicHJlc2VydmVkU2VnbWVudHMiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJtYXAiLCJwcmVzZXJ2ZWRTZWdtZW50IiwiVGVtcGxhdGVDb250ZXh0IiwiUHJvdmlkZXIiLCJrZXkiLCJFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJMb2FkaW5nQm91bmRhcnkiLCJOb3RGb3VuZEJvdW5kYXJ5IiwiUmVkaXJlY3RCb3VuZGFyeSIsInBhdGgiLCJpc0FjdGl2ZSIsIndhbGtBZGRSZWZldGNoIiwic2VnbWVudFBhdGhUb1dhbGsiLCJ0cmVlVG9SZWNyZWF0ZSIsInBhcmFsbGVsUm91dGVLZXkiLCJpc0xhc3QiLCJsZW5ndGgiLCJtYXRjaFNlZ21lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsInN1YlRyZWUiLCJ1bmRlZmluZWQiLCJzbGljZSIsInRvcE9mRWxlbWVudEluVmlld3BvcnQiLCJlbGVtZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvcCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJjaGFuZ2VCeVNlcnZlclJlc3BvbnNlIiwiZnVsbFRyZWUiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImZvY3VzQW5kU2Nyb2xsRWxlbWVudFJlZiIsInVzZVJlZiIsInVzZUVmZmVjdCIsImFwcGx5IiwiY3VycmVudCIsImZvY3VzIiwiaHRtbEVsZW1lbnQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImV4aXN0aW5nIiwic3R5bGUiLCJzY3JvbGxCZWhhdmlvciIsInNjcm9sbEludG9WaWV3IiwiY2hpbGROb2RlIiwic3RhdHVzIiwiQ2FjaGVTdGF0ZXMiLCJMQVpZSU5JVElBTElaRUQiLCJSRUFEWSIsInN1YlRyZWVEYXRhIiwiZGF0YSIsInBhcmFsbGVsUm91dGVzIiwicmVmZXRjaFRyZWUiLCJEQVRBRkVUQ0giLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJmbGlnaHREYXRhIiwib3ZlcnJpZGVDYW5vbmljYWxVcmwiLCJ1c2UiLCJ3aW5kb3ciLCJocmVmIiwic2V0VGltZW91dCIsInN0YXJ0VHJhbnNpdGlvbiIsImNyZWF0ZUluZmluaXRlUHJvbWlzZSIsInN1YnRyZWUiLCJyZWYiLCJjaGlsZHJlbiIsIlN1c3BlbnNlIiwiZmFsbGJhY2siLCJIYW5kbGVSZWRpcmVjdCIsInJlZGlyZWN0Iiwicm91dGVyIiwidXNlUm91dGVyIiwicmVwbGFjZSIsIlJlZGlyZWN0RXJyb3JCb3VuZGFyeSIsIkNvbXBvbmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImRpZ2VzdCIsInN0YXJ0c1dpdGgiLCJzcGxpdCIsInJlbmRlciIsInN0YXRlIiwicHJvcHMiLCJjb25zdHJ1Y3RvciIsIk5vdEZvdW5kRXJyb3JCb3VuZGFyeSIsIm5vdEZvdW5kVHJpZ2dlcmVkIiwibmFtZSIsImNvbnRlbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/match-segments.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/match-segments.js ***!
  \****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.matchSegment = void 0;\nconst matchSegment = (existingSegment, segment)=>{\n    // Common case: segment is just a string\n    if (typeof existingSegment === \"string\" && typeof segment === \"string\") {\n        return existingSegment === segment;\n    }\n    // Dynamic parameter case: segment is an array with param/value. Both param and value are compared.\n    if (Array.isArray(existingSegment) && Array.isArray(segment)) {\n        return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n    }\n    return false;\n};\nexports.matchSegment = matchSegment;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=match-segments.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtOGRmMmFlZGM0Ny8wL2NhY2hlL25leHQtbnBtLTEzLjAuMy1mYjg3YTE0MjRhLWYxZjZlOGE1NzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbWF0Y2gtc2VnbWVudHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsb0JBQW9CLEdBQUcsS0FBSztBQUM1QixNQUFNRSxlQUFlLENBQUNDLGlCQUFpQkMsVUFBVTtJQUM3Qyx3Q0FBd0M7SUFDeEMsSUFBSSxPQUFPRCxvQkFBb0IsWUFBWSxPQUFPQyxZQUFZLFVBQVU7UUFDcEUsT0FBT0Qsb0JBQW9CQztJQUMvQixDQUFDO0lBQ0QsbUdBQW1HO0lBQ25HLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsb0JBQW9CRSxNQUFNQyxPQUFPLENBQUNGLFVBQVU7UUFDMUQsT0FBT0QsZUFBZSxDQUFDLEVBQUUsS0FBS0MsT0FBTyxDQUFDLEVBQUUsSUFBSUQsZUFBZSxDQUFDLEVBQUUsS0FBS0MsT0FBTyxDQUFDLEVBQUU7SUFDakYsQ0FBQztJQUNELE9BQU8sS0FBSztBQUNoQjtBQUNBSixvQkFBb0IsR0FBR0U7QUFFdkIsSUFBSSxDQUFDLE9BQU9GLFFBQVFPLE9BQU8sS0FBSyxjQUFlLE9BQU9QLFFBQVFPLE9BQU8sS0FBSyxZQUFZUCxRQUFRTyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9QLFFBQVFPLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktWLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU8sT0FBTyxFQUFFLGNBQWM7UUFBRU4sT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9XLE1BQU0sQ0FBQ1QsUUFBUU8sT0FBTyxFQUFFUDtJQUMvQlUsT0FBT1YsT0FBTyxHQUFHQSxRQUFRTyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLThkZjJhZWRjNDcvMC9jYWNoZS9uZXh0LW5wbS0xMy4wLjMtZmI4N2ExNDI0YS1mMWY2ZThhNTc0LnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL21hdGNoLXNlZ21lbnRzLmpzP2JhM2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hdGNoU2VnbWVudCA9IHZvaWQgMDtcbmNvbnN0IG1hdGNoU2VnbWVudCA9IChleGlzdGluZ1NlZ21lbnQsIHNlZ21lbnQpPT57XG4gICAgLy8gQ29tbW9uIGNhc2U6IHNlZ21lbnQgaXMganVzdCBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmdTZWdtZW50ID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc2VnbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VnbWVudCA9PT0gc2VnbWVudDtcbiAgICB9XG4gICAgLy8gRHluYW1pYyBwYXJhbWV0ZXIgY2FzZTogc2VnbWVudCBpcyBhbiBhcnJheSB3aXRoIHBhcmFtL3ZhbHVlLiBCb3RoIHBhcmFtIGFuZCB2YWx1ZSBhcmUgY29tcGFyZWQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RpbmdTZWdtZW50KSAmJiBBcnJheS5pc0FycmF5KHNlZ21lbnQpKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1NlZ21lbnRbMF0gPT09IHNlZ21lbnRbMF0gJiYgZXhpc3RpbmdTZWdtZW50WzFdID09PSBzZWdtZW50WzFdO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0cy5tYXRjaFNlZ21lbnQgPSBtYXRjaFNlZ21lbnQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoLXNlZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hdGNoU2VnbWVudCIsImV4aXN0aW5nU2VnbWVudCIsInNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/match-segments.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/reducer.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/reducer.js ***!
  \*********************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createHrefFromUrl = createHrefFromUrl;\nexports.reducer = exports.ACTION_PREFETCH = exports.ACTION_SERVER_PATCH = exports.ACTION_RESTORE = exports.ACTION_NAVIGATE = exports.ACTION_REFRESH = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/match-segments.js\");\nvar _appRouter = __webpack_require__(/*! ./app-router */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/app-router.js\");\n/**\n * Create data fetching record for Promise.\n */ // TODO-APP: change `any` to type inference.\nfunction createRecordFromThenable(thenable) {\n    thenable.status = \"pending\";\n    thenable.then((value)=>{\n        if (thenable.status === \"pending\") {\n            thenable.status = \"fulfilled\";\n            thenable.value = value;\n        }\n    }, (err)=>{\n        if (thenable.status === \"pending\") {\n            thenable.status = \"rejected\";\n            thenable.value = err;\n        }\n    });\n    return thenable;\n}\n/**\n * Read record value or throw Promise if it's not resolved yet.\n */ function readRecordValue(thenable) {\n    if (thenable.status === \"fulfilled\") {\n        return thenable.value;\n    } else {\n        throw thenable;\n    }\n}\nfunction createHrefFromUrl(url) {\n    return url.pathname + url.search + url.hash;\n}\n/**\n * Invalidate cache one level down from the router state.\n */ // TODO-APP: Verify if this needs to be recursive.\nfunction invalidateCacheByRouterState(newCache, existingCache, routerState) {\n    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n    for(const key in routerState[1]){\n        const segmentForParallelRoute = routerState[1][key][0];\n        const cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n        if (existingParallelRoutesCacheNode) {\n            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n            parallelRouteCacheNode.delete(cacheKey);\n            newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        }\n    }\n}\nfunction fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, head) {\n    const isLastSegment = Object.keys(routerState[1]).length === 0;\n    if (isLastSegment) {\n        newCache.head = head;\n        return;\n    }\n    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n    for(const key in routerState[1]){\n        const parallelRouteState = routerState[1][key];\n        const segmentForParallelRoute = parallelRouteState[0];\n        const cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n        if (existingCache) {\n            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n            if (existingParallelRoutesCacheNode) {\n                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n                parallelRouteCacheNode.delete(cacheKey);\n                const newCacheNode = {\n                    status: _appRouterContext.CacheStates.LAZYINITIALIZED,\n                    data: null,\n                    subTreeData: null,\n                    parallelRoutes: new Map()\n                };\n                parallelRouteCacheNode.set(cacheKey, newCacheNode);\n                fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, head);\n                newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n                continue;\n            }\n        }\n        const newCacheNode1 = {\n            status: _appRouterContext.CacheStates.LAZYINITIALIZED,\n            data: null,\n            subTreeData: null,\n            parallelRoutes: new Map()\n        };\n        newCache.parallelRoutes.set(key, new Map([\n            [\n                cacheKey,\n                newCacheNode1\n            ]\n        ]));\n        fillLazyItemsTillLeafWithHead(newCacheNode1, undefined, parallelRouteState, head);\n    }\n}\n/**\n * Fill cache with subTreeData based on flightDataPath\n */ function fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath) {\n    const isLastEntry = flightDataPath.length <= 4;\n    const [parallelRouteKey, segment] = flightDataPath;\n    const segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    let childCacheNode = childSegmentMap.get(segmentForCache);\n    // In case of last segment start the fetch at this level and don't copy further down.\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childCacheNode = {\n                status: _appRouterContext.CacheStates.READY,\n                data: null,\n                subTreeData: flightDataPath[3],\n                // Ensure segments other than the one we got data for are preserved.\n                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map()\n            };\n            if (existingChildCacheNode) {\n                invalidateCacheByRouterState(childCacheNode, existingChildCacheNode, flightDataPath[2]);\n            }\n            fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], /* flightDataPath[4] */ undefined);\n            childSegmentMap.set(segmentForCache, childCacheNode);\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n    fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2));\n}\n/**\n * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n */ function invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    // In case of last entry don't copy further down.\n    if (isLastEntry) {\n        childSegmentMap.delete(segmentForCache);\n        return;\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    let childCacheNode = childSegmentMap.get(segmentForCache);\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\n/**\n * Fill cache with subTreeData based on flightDataPath that was prefetched\n * This operation is append-only to the existing cache.\n */ function fillCacheWithPrefetchedSubTreeData(existingCache, flightDataPath) {\n    const isLastEntry = flightDataPath.length <= 4;\n    const [parallelRouteKey, segment] = flightDataPath;\n    const segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        return;\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    if (isLastEntry) {\n        if (!existingChildCacheNode) {\n            existingChildSegmentMap.set(segmentForCache, {\n                status: _appRouterContext.CacheStates.READY,\n                data: null,\n                subTreeData: flightDataPath[3],\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (!existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        return;\n    }\n    fillCacheWithPrefetchedSubTreeData(existingChildCacheNode, flightDataPath.slice(2));\n}\n/**\n * Kick off fetch based on the common layout between two routes. Fill cache with data property holding the in-progress fetch.\n */ function fillCacheWithDataProperty(newCache, existingCache, segments, fetchResponse) {\n    const isLastEntry = segments.length === 1;\n    const parallelRouteKey = \"children\";\n    const [segment] = segments;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return {\n            bailOptimistic: true\n        };\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segment);\n    let childCacheNode = childSegmentMap.get(segment);\n    // In case of last segment start off the fetch at this level and don't copy further down.\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childSegmentMap.set(segment, {\n                status: _appRouterContext.CacheStates.DATAFETCH,\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Start fetch in the place where the existing cache doesn't have the data yet.\n        if (!childCacheNode) {\n            childSegmentMap.set(segment, {\n                status: _appRouterContext.CacheStates.DATAFETCH,\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segment, childCacheNode);\n    }\n    return fillCacheWithDataProperty(childCacheNode, existingChildCacheNode, segments.slice(1), fetchResponse);\n}\n/**\n * Create optimistic version of router state based on the existing router state and segments.\n * This is used to allow rendering layout-routers up till the point where data is missing.\n */ function createOptimisticTree(segments, flightRouterState, _isFirstSegment, parentRefetch, _href) {\n    const [existingSegment, existingParallelRoutes] = flightRouterState || [\n        null,\n        {}\n    ];\n    const segment = segments[0];\n    const isLastSegment = segments.length === 1;\n    const segmentMatches = existingSegment !== null && (0, _matchSegments).matchSegment(existingSegment, segment);\n    const shouldRefetchThisLevel = !flightRouterState || !segmentMatches;\n    let parallelRoutes = {};\n    if (existingSegment !== null && segmentMatches) {\n        parallelRoutes = existingParallelRoutes;\n    }\n    let childTree;\n    if (!isLastSegment) {\n        const childItem = createOptimisticTree(segments.slice(1), parallelRoutes ? parallelRoutes.children : null, false, parentRefetch || shouldRefetchThisLevel);\n        childTree = childItem;\n    }\n    const result = [\n        segment,\n        _extends({}, parallelRoutes, childTree ? {\n            children: childTree\n        } : {})\n    ];\n    if (!parentRefetch && shouldRefetchThisLevel) {\n        result[3] = \"refetch\";\n    }\n    // TODO-APP: Revisit\n    // Add url into the tree\n    // if (isFirstSegment) {\n    //   result[2] = href\n    // }\n    return result;\n}\n/**\n * Apply the router state from the Flight response. Creates a new router state tree.\n */ function applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch) {\n    const [segment, parallelRoutes, , , isRootLayout] = flightRouterState;\n    // Root refresh\n    if (flightSegmentPath.length === 1) {\n        const tree = [\n            ...treePatch\n        ];\n        // TODO-APP: revisit\n        // if (url) {\n        //   tree[2] = url\n        // }\n        return tree;\n    }\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Tree path returned from the server should always match up with the current tree in the browser\n    if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n        return null;\n    }\n    const lastSegment = flightSegmentPath.length === 2;\n    let parallelRoutePatch;\n    if (lastSegment) {\n        parallelRoutePatch = treePatch;\n    } else {\n        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n        if (parallelRoutePatch === null) {\n            return null;\n        }\n    }\n    const tree1 = [\n        flightSegmentPath[0],\n        _extends({}, parallelRoutes, {\n            [parallelRouteKey]: parallelRoutePatch\n        })\n    ];\n    // Current segment is the root layout\n    if (isRootLayout) {\n        tree1[4] = true;\n    }\n    // TODO-APP: Revisit\n    // if (url) {\n    //   tree[2] = url\n    // }\n    return tree1;\n}\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState, treePatch) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n}\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree  didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\nconst ACTION_REFRESH = \"refresh\";\nexports.ACTION_REFRESH = ACTION_REFRESH;\nconst ACTION_NAVIGATE = \"navigate\";\nexports.ACTION_NAVIGATE = ACTION_NAVIGATE;\nconst ACTION_RESTORE = \"restore\";\nexports.ACTION_RESTORE = ACTION_RESTORE;\nconst ACTION_SERVER_PATCH = \"server-patch\";\nexports.ACTION_SERVER_PATCH = ACTION_SERVER_PATCH;\nconst ACTION_PREFETCH = \"prefetch\";\nexports.ACTION_PREFETCH = ACTION_PREFETCH;\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case ACTION_NAVIGATE:\n            {\n                const { url , navigateType , cache , mutable , forceOptimisticNavigation  } = action;\n                const { pathname , search  } = url;\n                const href = createHrefFromUrl(url);\n                const pendingPush = navigateType === \"push\";\n                const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n                if (mutable.mpaNavigation && isForCurrentTree) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : href,\n                        // TODO-APP: verify mpaNavigation not being set is correct here.\n                        pushRef: {\n                            pendingPush,\n                            mpaNavigation: mutable.mpaNavigation\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Apply cache.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: state.tree\n                    };\n                }\n                // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n                if (mutable.patchedTree && isForCurrentTree) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : href,\n                        // TODO-APP: verify mpaNavigation not being set is correct here.\n                        pushRef: {\n                            pendingPush,\n                            mpaNavigation: false\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: true\n                        },\n                        // Apply cache.\n                        cache: mutable.useExistingCache ? state.cache : cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: mutable.patchedTree\n                    };\n                }\n                const prefetchValues = state.prefetchCache.get(href);\n                if (prefetchValues) {\n                    // The one before last item is the router state tree patch\n                    const { flightSegmentPath , tree: newTree , canonicalUrlOverride  } = prefetchValues;\n                    if (newTree !== null) {\n                        mutable.previousTree = state.tree;\n                        mutable.patchedTree = newTree;\n                        mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree);\n                        const hardNavigate = search !== location.search || shouldHardNavigate([\n                            \"\",\n                            ...flightSegmentPath\n                        ], state.tree, newTree);\n                        if (hardNavigate) {\n                            // TODO-APP: segments.slice(1) strips '', we can get rid of '' altogether.\n                            // Copy subTreeData for the root node of the cache.\n                            cache.subTreeData = state.cache.subTreeData;\n                            invalidateCacheBelowFlightSegmentPath(cache, state.cache, flightSegmentPath);\n                        } else {\n                            mutable.useExistingCache = true;\n                        }\n                        const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n                        if (canonicalUrlOverrideHref) {\n                            mutable.canonicalUrlOverride = canonicalUrlOverrideHref;\n                        }\n                        return {\n                            // Set href.\n                            canonicalUrl: canonicalUrlOverrideHref ? canonicalUrlOverrideHref : href,\n                            // Set pendingPush.\n                            pushRef: {\n                                pendingPush,\n                                mpaNavigation: false\n                            },\n                            // All navigation requires scroll and focus management to trigger.\n                            focusAndScrollRef: {\n                                apply: true\n                            },\n                            // Apply patched cache.\n                            cache: mutable.useExistingCache ? state.cache : cache,\n                            prefetchCache: state.prefetchCache,\n                            // Apply patched tree.\n                            tree: newTree\n                        };\n                    }\n                }\n                // When doing a hard push there can be two cases: with optimistic tree and without\n                // The with optimistic tree case only happens when the layouts have a loading state (loading.js)\n                // The without optimistic tree case happens when there is no loading state, in that case we suspend in this reducer\n                // forceOptimisticNavigation is used for links that have `prefetch={false}`.\n                if (forceOptimisticNavigation) {\n                    const segments = pathname.split(\"/\");\n                    // TODO-APP: figure out something better for index pages\n                    segments.push(\"\");\n                    // Optimistic tree case.\n                    // If the optimistic tree is deeper than the current state leave that deeper part out of the fetch\n                    const optimisticTree = createOptimisticTree(segments, state.tree, true, false, href);\n                    // Copy subTreeData for the root node of the cache.\n                    cache.subTreeData = state.cache.subTreeData;\n                    // Copy existing cache nodes as far as possible and fill in `data` property with the started data fetch.\n                    // The `data` property is used to suspend in layout-router during render if it hasn't resolved yet by the time it renders.\n                    const res = fillCacheWithDataProperty(cache, state.cache, segments.slice(1), ()=>(0, _appRouter).fetchServerResponse(url, optimisticTree));\n                    // If optimistic fetch couldn't happen it falls back to the non-optimistic case.\n                    if (!(res == null ? void 0 : res.bailOptimistic)) {\n                        mutable.previousTree = state.tree;\n                        mutable.patchedTree = optimisticTree;\n                        mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, optimisticTree);\n                        return {\n                            // Set href.\n                            canonicalUrl: href,\n                            // Set pendingPush.\n                            pushRef: {\n                                pendingPush,\n                                mpaNavigation: false\n                            },\n                            // All navigation requires scroll and focus management to trigger.\n                            focusAndScrollRef: {\n                                apply: true\n                            },\n                            // Apply patched cache.\n                            cache: cache,\n                            prefetchCache: state.prefetchCache,\n                            // Apply optimistic tree.\n                            tree: optimisticTree\n                        };\n                    }\n                }\n                // Below is the not-optimistic case. Data is fetched at the root and suspended there without a suspense boundary.\n                // If no in-flight fetch at the top, start it.\n                if (!cache.data) {\n                    cache.data = createRecordFromThenable((0, _appRouter).fetchServerResponse(url, state.tree));\n                }\n                // Unwrap cache data with `use` to suspend here (in the reducer) until the fetch resolves.\n                const [flightData, canonicalUrlOverride1] = readRecordValue(cache.data);\n                // Handle case when navigating to page in `pages` from `app`\n                if (typeof flightData === \"string\") {\n                    return {\n                        canonicalUrl: flightData,\n                        // Enable mpaNavigation\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: true\n                        },\n                        // Don't apply scroll and focus management.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        tree: state.tree\n                    };\n                }\n                // Remove cache.data as it has been resolved at this point.\n                cache.data = null;\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                const flightDataPath = flightData[0];\n                // The one before last item is the router state tree patch\n                const [treePatch, subTreeData] = flightDataPath.slice(-2);\n                // Path without the last segment, router state, and the subTreeData\n                const flightSegmentPath1 = flightDataPath.slice(0, -3);\n                // Create new tree based on the flightSegmentPath and router state patch\n                const newTree1 = applyRouterStatePatchToTree([\n                    \"\",\n                    ...flightSegmentPath1\n                ], state.tree, treePatch);\n                if (newTree1 === null) {\n                    throw new Error(\"SEGMENT MISMATCH\");\n                }\n                const canonicalUrlOverrideHref1 = canonicalUrlOverride1 ? createHrefFromUrl(canonicalUrlOverride1) : undefined;\n                if (canonicalUrlOverrideHref1) {\n                    mutable.canonicalUrlOverride = canonicalUrlOverrideHref1;\n                }\n                mutable.previousTree = state.tree;\n                mutable.patchedTree = newTree1;\n                mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree1);\n                if (flightDataPath.length === 2) {\n                    cache.subTreeData = subTreeData;\n                } else {\n                    // Copy subTreeData for the root node of the cache.\n                    cache.subTreeData = state.cache.subTreeData;\n                    // Create a copy of the existing cache with the subTreeData applied.\n                    fillCacheWithNewSubTreeData(cache, state.cache, flightDataPath);\n                }\n                return {\n                    // Set href.\n                    canonicalUrl: canonicalUrlOverrideHref1 ? canonicalUrlOverrideHref1 : href,\n                    // Set pendingPush.\n                    pushRef: {\n                        pendingPush,\n                        mpaNavigation: false\n                    },\n                    // All navigation requires scroll and focus management to trigger.\n                    focusAndScrollRef: {\n                        apply: true\n                    },\n                    // Apply patched cache.\n                    cache: cache,\n                    prefetchCache: state.prefetchCache,\n                    // Apply patched tree.\n                    tree: newTree1\n                };\n            }\n        case ACTION_SERVER_PATCH:\n            {\n                const { flightData: flightData1 , previousTree , overrideCanonicalUrl , cache: cache1 , mutable: mutable1  } = action;\n                // When a fetch is slow to resolve it could be that you navigated away while the request was happening or before the reducer runs.\n                // In that case opt-out of applying the patch given that the data could be stale.\n                if (JSON.stringify(previousTree) !== JSON.stringify(state.tree)) {\n                    // TODO-APP: Handle tree mismatch\n                    console.log(\"TREE MISMATCH\");\n                    // Keep everything as-is.\n                    return state;\n                }\n                if (mutable1.mpaNavigation) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable1.canonicalUrlOverride ? mutable1.canonicalUrlOverride : state.canonicalUrl,\n                        // TODO-APP: verify mpaNavigation not being set is correct here.\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: mutable1.mpaNavigation\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Apply cache.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: state.tree\n                    };\n                }\n                // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n                if (mutable1.patchedTree) {\n                    return {\n                        // Keep href as it was set during navigate / restore\n                        canonicalUrl: mutable1.canonicalUrlOverride ? mutable1.canonicalUrlOverride : state.canonicalUrl,\n                        // Keep pushRef as server-patch only causes cache/tree update.\n                        pushRef: state.pushRef,\n                        // Keep focusAndScrollRef as server-patch only causes cache/tree update.\n                        focusAndScrollRef: state.focusAndScrollRef,\n                        // Apply patched router state\n                        tree: mutable1.patchedTree,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched cache\n                        cache: cache1\n                    };\n                }\n                // Handle case when navigating to page in `pages` from `app`\n                if (typeof flightData1 === \"string\") {\n                    return {\n                        // Set href.\n                        canonicalUrl: flightData1,\n                        // Enable mpaNavigation as this is a navigation that the app-router shouldn't handle.\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: true\n                        },\n                        // Don't apply scroll and focus management.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Other state is kept as-is.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        tree: state.tree\n                    };\n                }\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                const flightDataPath1 = flightData1[0];\n                // Slices off the last segment (which is at -3) as it doesn't exist in the tree yet\n                const treePath = flightDataPath1.slice(0, -3);\n                const [treePatch1, subTreeData1] = flightDataPath1.slice(-2);\n                const newTree2 = applyRouterStatePatchToTree([\n                    \"\",\n                    ...treePath\n                ], state.tree, treePatch1);\n                if (newTree2 === null) {\n                    throw new Error(\"SEGMENT MISMATCH\");\n                }\n                const canonicalUrlOverrideHref2 = overrideCanonicalUrl ? createHrefFromUrl(overrideCanonicalUrl) : undefined;\n                if (canonicalUrlOverrideHref2) {\n                    mutable1.canonicalUrlOverride = canonicalUrlOverrideHref2;\n                }\n                mutable1.patchedTree = newTree2;\n                mutable1.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree2);\n                // Root refresh\n                if (flightDataPath1.length === 2) {\n                    cache1.subTreeData = subTreeData1;\n                } else {\n                    // Copy subTreeData for the root node of the cache.\n                    cache1.subTreeData = state.cache.subTreeData;\n                    fillCacheWithNewSubTreeData(cache1, state.cache, flightDataPath1);\n                }\n                return {\n                    // Keep href as it was set during navigate / restore\n                    canonicalUrl: canonicalUrlOverrideHref2 ? canonicalUrlOverrideHref2 : state.canonicalUrl,\n                    // Keep pushRef as server-patch only causes cache/tree update.\n                    pushRef: state.pushRef,\n                    // Keep focusAndScrollRef as server-patch only causes cache/tree update.\n                    focusAndScrollRef: state.focusAndScrollRef,\n                    // Apply patched router state\n                    tree: newTree2,\n                    prefetchCache: state.prefetchCache,\n                    // Apply patched cache\n                    cache: cache1\n                };\n            }\n        case ACTION_RESTORE:\n            {\n                const { url: url1 , tree  } = action;\n                const href1 = createHrefFromUrl(url1);\n                return {\n                    // Set canonical url\n                    canonicalUrl: href1,\n                    pushRef: state.pushRef,\n                    focusAndScrollRef: state.focusAndScrollRef,\n                    cache: state.cache,\n                    prefetchCache: state.prefetchCache,\n                    // Restore provided tree\n                    tree: tree\n                };\n            }\n        // TODO-APP: Add test for not scrolling to nearest layout when calling refresh.\n        // TODO-APP: Add test for startTransition(() => {router.push('/'); router.refresh();}), that case should scroll.\n        case ACTION_REFRESH:\n            {\n                const { cache: cache2 , mutable: mutable2  } = action;\n                const href2 = state.canonicalUrl;\n                const isForCurrentTree1 = JSON.stringify(mutable2.previousTree) === JSON.stringify(state.tree);\n                if (mutable2.mpaNavigation && isForCurrentTree1) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable2.canonicalUrlOverride ? mutable2.canonicalUrlOverride : state.canonicalUrl,\n                        // TODO-APP: verify mpaNavigation not being set is correct here.\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: mutable2.mpaNavigation\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Apply cache.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: state.tree\n                    };\n                }\n                // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n                if (mutable2.patchedTree && isForCurrentTree1) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable2.canonicalUrlOverride ? mutable2.canonicalUrlOverride : href2,\n                        // set pendingPush (always false in this case).\n                        pushRef: state.pushRef,\n                        // Apply focus and scroll.\n                        // TODO-APP: might need to disable this for Fast Refresh.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        cache: cache2,\n                        prefetchCache: state.prefetchCache,\n                        tree: mutable2.patchedTree\n                    };\n                }\n                if (!cache2.data) {\n                    // Fetch data from the root of the tree.\n                    cache2.data = createRecordFromThenable((0, _appRouter).fetchServerResponse(new URL(href2, location.origin), [\n                        state.tree[0],\n                        state.tree[1],\n                        state.tree[2],\n                        \"refetch\"\n                    ]));\n                }\n                const [flightData2, canonicalUrlOverride2] = readRecordValue(cache2.data);\n                // Handle case when navigating to page in `pages` from `app`\n                if (typeof flightData2 === \"string\") {\n                    return {\n                        canonicalUrl: flightData2,\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: true\n                        },\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        tree: state.tree\n                    };\n                }\n                // Remove cache.data as it has been resolved at this point.\n                cache2.data = null;\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                const flightDataPath2 = flightData2[0];\n                // FlightDataPath with more than two items means unexpected Flight data was returned\n                if (flightDataPath2.length !== 2) {\n                    // TODO-APP: handle this case better\n                    console.log(\"REFRESH FAILED\");\n                    return state;\n                }\n                // Given the path can only have two items the items are only the router state and subTreeData for the root.\n                const [treePatch2, subTreeData2] = flightDataPath2;\n                const newTree3 = applyRouterStatePatchToTree([\n                    \"\"\n                ], state.tree, treePatch2);\n                if (newTree3 === null) {\n                    throw new Error(\"SEGMENT MISMATCH\");\n                }\n                const canonicalUrlOverrideHref3 = canonicalUrlOverride2 ? createHrefFromUrl(canonicalUrlOverride2) : undefined;\n                if (canonicalUrlOverride2) {\n                    mutable2.canonicalUrlOverride = canonicalUrlOverrideHref3;\n                }\n                mutable2.previousTree = state.tree;\n                mutable2.patchedTree = newTree3;\n                mutable2.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree3);\n                // Set subTreeData for the root node of the cache.\n                cache2.subTreeData = subTreeData2;\n                return {\n                    // Set href, this doesn't reuse the state.canonicalUrl as because of concurrent rendering the href might change between dispatching and applying.\n                    canonicalUrl: canonicalUrlOverrideHref3 ? canonicalUrlOverrideHref3 : href2,\n                    // set pendingPush (always false in this case).\n                    pushRef: state.pushRef,\n                    // TODO-APP: might need to disable this for Fast Refresh.\n                    focusAndScrollRef: {\n                        apply: false\n                    },\n                    // Apply patched cache.\n                    cache: cache2,\n                    prefetchCache: state.prefetchCache,\n                    // Apply patched router state.\n                    tree: newTree3\n                };\n            }\n        case ACTION_PREFETCH:\n            {\n                const { url: url2 , serverResponse  } = action;\n                const [flightData3, canonicalUrlOverride3] = serverResponse;\n                // TODO-APP: Implement prefetch for hard navigation\n                if (typeof flightData3 === \"string\") {\n                    return state;\n                }\n                const href3 = createHrefFromUrl(url2);\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                const flightDataPath3 = flightData3[0];\n                // The one before last item is the router state tree patch\n                const [treePatch3, subTreeData3] = flightDataPath3.slice(-2);\n                // TODO-APP: Verify if `null` can't be returned from user code.\n                // If subTreeData is null the prefetch did not provide a component tree.\n                if (subTreeData3 !== null) {\n                    fillCacheWithPrefetchedSubTreeData(state.cache, flightDataPath3);\n                }\n                const flightSegmentPath2 = flightDataPath3.slice(0, -2);\n                const newTree4 = applyRouterStatePatchToTree([\n                    \"\",\n                    ...flightSegmentPath2\n                ], state.tree, treePatch3);\n                // Patch did not apply correctly\n                if (newTree4 === null) {\n                    return state;\n                }\n                // Create new tree based on the flightSegmentPath and router state patch\n                state.prefetchCache.set(href3, {\n                    // Path without the last segment, router state, and the subTreeData\n                    flightSegmentPath: flightSegmentPath2,\n                    // Create new tree based on the flightSegmentPath and router state patch\n                    tree: newTree4,\n                    canonicalUrlOverride: canonicalUrlOverride3\n                });\n                return state;\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw new Error(\"Unknown action\");\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer =  false ? 0 : clientReducer;\nexports.reducer = reducer;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtOGRmMmFlZGM0Ny8wL2NhY2hlL25leHQtbnBtLTEzLjAuMy1mYjg3YTE0MjRhLWYxZjZlOGE1NzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVkdWNlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx5QkFBeUIsR0FBR0U7QUFDNUJGLGVBQWUsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSxzQkFBc0IsR0FBR0EsdUJBQXVCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDM0osSUFBSVMsV0FBV0MsaUxBQStDO0FBQzlELElBQUlFLG9CQUFvQkYsbUJBQU9BLENBQUMsa01BQXFDO0FBQ3JFLElBQUlHLGlCQUFpQkgsbUJBQU9BLENBQUMsa0xBQWtCO0FBQy9DLElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDLDBLQUFjO0FBQ3ZDOztDQUVDLEdBQUcsNENBQTRDO0FBQ2hELFNBQVNLLHlCQUF5QkMsUUFBUSxFQUFFO0lBQ3hDQSxTQUFTQyxNQUFNLEdBQUc7SUFDbEJELFNBQVNFLElBQUksQ0FBQyxDQUFDakIsUUFBUTtRQUNuQixJQUFJZSxTQUFTQyxNQUFNLEtBQUssV0FBVztZQUMvQkQsU0FBU0MsTUFBTSxHQUFHO1lBQ2xCRCxTQUFTZixLQUFLLEdBQUdBO1FBQ3JCLENBQUM7SUFDTCxHQUFHLENBQUNrQixNQUFNO1FBQ04sSUFBSUgsU0FBU0MsTUFBTSxLQUFLLFdBQVc7WUFDL0JELFNBQVNDLE1BQU0sR0FBRztZQUNsQkQsU0FBU2YsS0FBSyxHQUFHa0I7UUFDckIsQ0FBQztJQUNMO0lBQ0EsT0FBT0g7QUFDWDtBQUNBOztDQUVDLEdBQUcsU0FBU0ksZ0JBQWdCSixRQUFRLEVBQUU7SUFDbkMsSUFBSUEsU0FBU0MsTUFBTSxLQUFLLGFBQWE7UUFDakMsT0FBT0Qs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YTtBQUM3RXZHLGVBQWUsR0FBR0c7QUFFbEIsSUFBSSxDQUFDLE9BQU9ILFFBQVFXLE9BQU8sS0FBSyxjQUFlLE9BQU9YLFFBQVFXLE9BQU8sS0FBSyxZQUFZWCxRQUFRVyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9YLFFBQVFXLE9BQU8sQ0FBQ3dJLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckosT0FBT0MsY0FBYyxDQUFDQyxRQUFRVyxPQUFPLEVBQUUsY0FBYztRQUFFVixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3NKLE1BQU0sQ0FBQ3BKLFFBQVFXLE9BQU8sRUFBRVg7SUFDL0JxSixPQUFPckosT0FBTyxHQUFHQSxRQUFRVyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLThkZjJhZWRjNDcvMC9jYWNoZS9uZXh0LW5wbS0xMy4wLjMtZmI4N2ExNDI0YS1mMWY2ZThhNTc0LnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlZHVjZXIuanM/MTU3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlSHJlZkZyb21VcmwgPSBjcmVhdGVIcmVmRnJvbVVybDtcbmV4cG9ydHMucmVkdWNlciA9IGV4cG9ydHMuQUNUSU9OX1BSRUZFVENIID0gZXhwb3J0cy5BQ1RJT05fU0VSVkVSX1BBVENIID0gZXhwb3J0cy5BQ1RJT05fUkVTVE9SRSA9IGV4cG9ydHMuQUNUSU9OX05BVklHQVRFID0gZXhwb3J0cy5BQ1RJT05fUkVGUkVTSCA9IHZvaWQgMDtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX21hdGNoU2VnbWVudHMgPSByZXF1aXJlKFwiLi9tYXRjaC1zZWdtZW50c1wiKTtcbnZhciBfYXBwUm91dGVyID0gcmVxdWlyZShcIi4vYXBwLXJvdXRlclwiKTtcbi8qKlxuICogQ3JlYXRlIGRhdGEgZmV0Y2hpbmcgcmVjb3JkIGZvciBQcm9taXNlLlxuICovIC8vIFRPRE8tQVBQOiBjaGFuZ2UgYGFueWAgdG8gdHlwZSBpbmZlcmVuY2UuXG5mdW5jdGlvbiBjcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICB0aGVuYWJsZS5zdGF0dXMgPSAncGVuZGluZyc7XG4gICAgdGhlbmFibGUudGhlbigodmFsdWUpPT57XG4gICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgdGhlbmFibGUuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgICAgICAgICB0aGVuYWJsZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSwgKGVycik9PntcbiAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICB0aGVuYWJsZS5zdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgICAgICAgICAgdGhlbmFibGUudmFsdWUgPSBlcnI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhlbmFibGU7XG59XG4vKipcbiAqIFJlYWQgcmVjb3JkIHZhbHVlIG9yIHRocm93IFByb21pc2UgaWYgaXQncyBub3QgcmVzb2x2ZWQgeWV0LlxuICovIGZ1bmN0aW9uIHJlYWRSZWNvcmRWYWx1ZSh0aGVuYWJsZSkge1xuICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGVuYWJsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVIcmVmRnJvbVVybCh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoO1xufVxuLyoqXG4gKiBJbnZhbGlkYXRlIGNhY2hlIG9uZSBsZXZlbCBkb3duIGZyb20gdGhlIHJvdXRlciBzdGF0ZS5cbiAqLyAvLyBUT0RPLUFQUDogVmVyaWZ5IGlmIHRoaXMgbmVlZHMgdG8gYmUgcmVjdXJzaXZlLlxuZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgcm91dGVyU3RhdGUpIHtcbiAgICAvLyBSZW1vdmUgc2VnbWVudCB0aGF0IHdlIGdvdCBkYXRhIGZvciBzbyB0aGF0IGl0IGlzIGZpbGxlZCBpbiBkdXJpbmcgcmVuZGVyaW5nIG9mIHN1YlRyZWVEYXRhLlxuICAgIGZvcihjb25zdCBrZXkgaW4gcm91dGVyU3RhdGVbMV0pe1xuICAgICAgICBjb25zdCBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSA9IHJvdXRlclN0YXRlWzFdW2tleV1bMF07XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gQXJyYXkuaXNBcnJheShzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSkgPyBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZVsxXSA6IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlO1xuICAgICAgICBjb25zdCBleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGxldCBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlID0gbmV3IE1hcChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKTtcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIHJvdXRlclN0YXRlLCBoZWFkKSB7XG4gICAgY29uc3QgaXNMYXN0U2VnbWVudCA9IE9iamVjdC5rZXlzKHJvdXRlclN0YXRlWzFdKS5sZW5ndGggPT09IDA7XG4gICAgaWYgKGlzTGFzdFNlZ21lbnQpIHtcbiAgICAgICAgbmV3Q2FjaGUuaGVhZCA9IGhlYWQ7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHNlZ21lbnQgdGhhdCB3ZSBnb3QgZGF0YSBmb3Igc28gdGhhdCBpdCBpcyBmaWxsZWQgaW4gZHVyaW5nIHJlbmRlcmluZyBvZiBzdWJUcmVlRGF0YS5cbiAgICBmb3IoY29uc3Qga2V5IGluIHJvdXRlclN0YXRlWzFdKXtcbiAgICAgICAgY29uc3QgcGFyYWxsZWxSb3V0ZVN0YXRlID0gcm91dGVyU3RhdGVbMV1ba2V5XTtcbiAgICAgICAgY29uc3Qgc2VnbWVudEZvclBhcmFsbGVsUm91dGUgPSBwYXJhbGxlbFJvdXRlU3RhdGVbMF07XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gQXJyYXkuaXNBcnJheShzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSkgPyBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZVsxXSA6IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlO1xuICAgICAgICBpZiAoZXhpc3RpbmdDYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlID0gbmV3IE1hcChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKTtcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllJTklUSUFMSVpFRCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUuc2V0KGNhY2hlS2V5LCBuZXdDYWNoZU5vZGUpO1xuICAgICAgICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKG5ld0NhY2hlTm9kZSwgdW5kZWZpbmVkLCBwYXJhbGxlbFJvdXRlU3RhdGUsIGhlYWQpO1xuICAgICAgICAgICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuTEFaWUlOSVRJQUxJWkVELFxuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQoa2V5LCBuZXcgTWFwKFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICBuZXdDYWNoZU5vZGVcbiAgICAgICAgICAgIF1cbiAgICAgICAgXSkpO1xuICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChuZXdDYWNoZU5vZGUsIHVuZGVmaW5lZCwgcGFyYWxsZWxSb3V0ZVN0YXRlLCBoZWFkKTtcbiAgICB9XG59XG4vKipcbiAqIEZpbGwgY2FjaGUgd2l0aCBzdWJUcmVlRGF0YSBiYXNlZCBvbiBmbGlnaHREYXRhUGF0aFxuICovIGZ1bmN0aW9uIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgZmxpZ2h0RGF0YVBhdGgpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IGZsaWdodERhdGFQYXRoLmxlbmd0aCA8PSA0O1xuICAgIGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBzZWdtZW50XSA9IGZsaWdodERhdGFQYXRoO1xuICAgIGNvbnN0IHNlZ21lbnRGb3JDYWNoZSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudCkgPyBzZWdtZW50WzFdIDogc2VnbWVudDtcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKTtcbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgLy8gSW4gY2FzZSBvZiBsYXN0IHNlZ21lbnQgc3RhcnQgdGhlIGZldGNoIGF0IHRoaXMgbGV2ZWwgYW5kIGRvbid0IGNvcHkgZnVydGhlciBkb3duLlxuICAgIGlmIChpc0xhc3RFbnRyeSkge1xuICAgICAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFjaGlsZENhY2hlTm9kZS5kYXRhIHx8IGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IGZsaWdodERhdGFQYXRoWzNdLFxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBzZWdtZW50cyBvdGhlciB0aGFuIHRoZSBvbmUgd2UgZ290IGRhdGEgZm9yIGFyZSBwcmVzZXJ2ZWQuXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPyBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMpIDogbmV3IE1hcCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlKGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHREYXRhUGF0aFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0RGF0YVBhdGhbMl0sIC8qIGZsaWdodERhdGFQYXRoWzRdICovIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnRGb3JDYWNoZSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBjaGlsZENhY2hlTm9kZS5zdGF0dXMsXG4gICAgICAgICAgICBkYXRhOiBjaGlsZENhY2hlTm9kZS5kYXRhLFxuICAgICAgICAgICAgc3ViVHJlZURhdGE6IGNoaWxkQ2FjaGVOb2RlLnN1YlRyZWVEYXRhLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoY2hpbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMpXG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudEZvckNhY2hlLCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0RGF0YVBhdGguc2xpY2UoMikpO1xufVxuLyoqXG4gKiBGaWxsIGNhY2hlIHVwIHRvIHRoZSBlbmQgb2YgdGhlIGZsaWdodFNlZ21lbnRQYXRoLCBpbnZhbGlkYXRpbmcgYW55dGhpbmcgYmVsb3cgaXQuXG4gKi8gZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aChuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyO1xuICAgIGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBzZWdtZW50XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIGNvbnN0IHNlZ21lbnRGb3JDYWNoZSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudCkgPyBzZWdtZW50WzFdIDogc2VnbWVudDtcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKTtcbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcCk7XG4gICAgfVxuICAgIC8vIEluIGNhc2Ugb2YgbGFzdCBlbnRyeSBkb24ndCBjb3B5IGZ1cnRoZXIgZG93bi5cbiAgICBpZiAoaXNMYXN0RW50cnkpIHtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLmRlbGV0ZShzZWdtZW50Rm9yQ2FjaGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBjaGlsZENhY2hlTm9kZS5zdGF0dXMsXG4gICAgICAgICAgICBkYXRhOiBjaGlsZENhY2hlTm9kZS5kYXRhLFxuICAgICAgICAgICAgc3ViVHJlZURhdGE6IGNoaWxkQ2FjaGVOb2RlLnN1YlRyZWVEYXRhLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoY2hpbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMpXG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudEZvckNhY2hlLCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodFNlZ21lbnRQYXRoLnNsaWNlKDIpKTtcbn1cbi8qKlxuICogRmlsbCBjYWNoZSB3aXRoIHN1YlRyZWVEYXRhIGJhc2VkIG9uIGZsaWdodERhdGFQYXRoIHRoYXQgd2FzIHByZWZldGNoZWRcbiAqIFRoaXMgb3BlcmF0aW9uIGlzIGFwcGVuZC1vbmx5IHRvIHRoZSBleGlzdGluZyBjYWNoZS5cbiAqLyBmdW5jdGlvbiBmaWxsQ2FjaGVXaXRoUHJlZmV0Y2hlZFN1YlRyZWVEYXRhKGV4aXN0aW5nQ2FjaGUsIGZsaWdodERhdGFQYXRoKSB7XG4gICAgY29uc3QgaXNMYXN0RW50cnkgPSBmbGlnaHREYXRhUGF0aC5sZW5ndGggPD0gNDtcbiAgICBjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgc2VnbWVudF0gPSBmbGlnaHREYXRhUGF0aDtcbiAgICBjb25zdCBzZWdtZW50Rm9yQ2FjaGUgPSBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnQ7XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAgPSBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50Rm9yQ2FjaGUpO1xuICAgIGlmIChpc0xhc3RFbnRyeSkge1xuICAgICAgICBpZiAoIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50Rm9yQ2FjaGUsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IGZsaWdodERhdGFQYXRoWzNdLFxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmlsbENhY2hlV2l0aFByZWZldGNoZWRTdWJUcmVlRGF0YShleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHREYXRhUGF0aC5zbGljZSgyKSk7XG59XG4vKipcbiAqIEtpY2sgb2ZmIGZldGNoIGJhc2VkIG9uIHRoZSBjb21tb24gbGF5b3V0IGJldHdlZW4gdHdvIHJvdXRlcy4gRmlsbCBjYWNoZSB3aXRoIGRhdGEgcHJvcGVydHkgaG9sZGluZyB0aGUgaW4tcHJvZ3Jlc3MgZmV0Y2guXG4gKi8gZnVuY3Rpb24gZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgc2VnbWVudHMsIGZldGNoUmVzcG9uc2UpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IHNlZ21lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCBwYXJhbGxlbFJvdXRlS2V5ID0gJ2NoaWxkcmVuJztcbiAgICBjb25zdCBbc2VnbWVudF0gPSBzZWdtZW50cztcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFpbE9wdGltaXN0aWM6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGNoaWxkU2VnbWVudE1hcCA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApO1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50KTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnQpO1xuICAgIC8vIEluIGNhc2Ugb2YgbGFzdCBzZWdtZW50IHN0YXJ0IG9mZiB0aGUgZmV0Y2ggYXQgdGhpcyBsZXZlbCBhbmQgZG9uJ3QgY29weSBmdXJ0aGVyIGRvd24uXG4gICAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWNoaWxkQ2FjaGVOb2RlLmRhdGEgfHwgY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuREFUQUZFVENILFxuICAgICAgICAgICAgICAgIGRhdGE6IGZldGNoUmVzcG9uc2UoKSxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgLy8gU3RhcnQgZmV0Y2ggaW4gdGhlIHBsYWNlIHdoZXJlIHRoZSBleGlzdGluZyBjYWNoZSBkb2Vzbid0IGhhdmUgdGhlIGRhdGEgeWV0LlxuICAgICAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnQsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkRBVEFGRVRDSCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmZXRjaFJlc3BvbnNlKCksXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IGNoaWxkQ2FjaGVOb2RlLnN0YXR1cyxcbiAgICAgICAgICAgIGRhdGE6IGNoaWxkQ2FjaGVOb2RlLmRhdGEsXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRDYWNoZU5vZGUuc3ViVHJlZURhdGEsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcylcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50LCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5KGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBzZWdtZW50cy5zbGljZSgxKSwgZmV0Y2hSZXNwb25zZSk7XG59XG4vKipcbiAqIENyZWF0ZSBvcHRpbWlzdGljIHZlcnNpb24gb2Ygcm91dGVyIHN0YXRlIGJhc2VkIG9uIHRoZSBleGlzdGluZyByb3V0ZXIgc3RhdGUgYW5kIHNlZ21lbnRzLlxuICogVGhpcyBpcyB1c2VkIHRvIGFsbG93IHJlbmRlcmluZyBsYXlvdXQtcm91dGVycyB1cCB0aWxsIHRoZSBwb2ludCB3aGVyZSBkYXRhIGlzIG1pc3NpbmcuXG4gKi8gZnVuY3Rpb24gY3JlYXRlT3B0aW1pc3RpY1RyZWUoc2VnbWVudHMsIGZsaWdodFJvdXRlclN0YXRlLCBfaXNGaXJzdFNlZ21lbnQsIHBhcmVudFJlZmV0Y2gsIF9ocmVmKSB7XG4gICAgY29uc3QgW2V4aXN0aW5nU2VnbWVudCwgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJTdGF0ZSB8fCBbXG4gICAgICAgIG51bGwsXG4gICAgICAgIHt9LCBcbiAgICBdO1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1swXTtcbiAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gc2VnbWVudHMubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IHNlZ21lbnRNYXRjaGVzID0gZXhpc3RpbmdTZWdtZW50ICE9PSBudWxsICYmICgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGV4aXN0aW5nU2VnbWVudCwgc2VnbWVudCk7XG4gICAgY29uc3Qgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCA9ICFmbGlnaHRSb3V0ZXJTdGF0ZSB8fCAhc2VnbWVudE1hdGNoZXM7XG4gICAgbGV0IHBhcmFsbGVsUm91dGVzID0ge307XG4gICAgaWYgKGV4aXN0aW5nU2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50TWF0Y2hlcykge1xuICAgICAgICBwYXJhbGxlbFJvdXRlcyA9IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXM7XG4gICAgfVxuICAgIGxldCBjaGlsZFRyZWU7XG4gICAgaWYgKCFpc0xhc3RTZWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkSXRlbSA9IGNyZWF0ZU9wdGltaXN0aWNUcmVlKHNlZ21lbnRzLnNsaWNlKDEpLCBwYXJhbGxlbFJvdXRlcyA/IHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuIDogbnVsbCwgZmFsc2UsIHBhcmVudFJlZmV0Y2ggfHwgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCk7XG4gICAgICAgIGNoaWxkVHJlZSA9IGNoaWxkSXRlbTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW1xuICAgICAgICBzZWdtZW50LFxuICAgICAgICBfZXh0ZW5kcyh7fSwgcGFyYWxsZWxSb3V0ZXMsIGNoaWxkVHJlZSA/IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZFRyZWVcbiAgICAgICAgfSA6IHt9KSwgXG4gICAgXTtcbiAgICBpZiAoIXBhcmVudFJlZmV0Y2ggJiYgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCkge1xuICAgICAgICByZXN1bHRbM10gPSAncmVmZXRjaCc7XG4gICAgfVxuICAgIC8vIFRPRE8tQVBQOiBSZXZpc2l0XG4gICAgLy8gQWRkIHVybCBpbnRvIHRoZSB0cmVlXG4gICAgLy8gaWYgKGlzRmlyc3RTZWdtZW50KSB7XG4gICAgLy8gICByZXN1bHRbMl0gPSBocmVmXG4gICAgLy8gfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEFwcGx5IHRoZSByb3V0ZXIgc3RhdGUgZnJvbSB0aGUgRmxpZ2h0IHJlc3BvbnNlLiBDcmVhdGVzIGEgbmV3IHJvdXRlciBzdGF0ZSB0cmVlLlxuICovIGZ1bmN0aW9uIGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShmbGlnaHRTZWdtZW50UGF0aCwgZmxpZ2h0Um91dGVyU3RhdGUsIHRyZWVQYXRjaCkge1xuICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlcywgLCAsIGlzUm9vdExheW91dF0gPSBmbGlnaHRSb3V0ZXJTdGF0ZTtcbiAgICAvLyBSb290IHJlZnJlc2hcbiAgICBpZiAoZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHRyZWUgPSBbXG4gICAgICAgICAgICAuLi50cmVlUGF0Y2hcbiAgICAgICAgXTtcbiAgICAgICAgLy8gVE9ETy1BUFA6IHJldmlzaXRcbiAgICAgICAgLy8gaWYgKHVybCkge1xuICAgICAgICAvLyAgIHRyZWVbMl0gPSB1cmxcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG4gICAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIC8vIFRyZWUgcGF0aCByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBtYXRjaCB1cCB3aXRoIHRoZSBjdXJyZW50IHRyZWUgaW4gdGhlIGJyb3dzZXJcbiAgICBpZiAoISgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFzdFNlZ21lbnQgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDI7XG4gICAgbGV0IHBhcmFsbGVsUm91dGVQYXRjaDtcbiAgICBpZiAobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZVBhdGNoID0gdHJlZVBhdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFsbGVsUm91dGVQYXRjaCA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSwgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sIHRyZWVQYXRjaCk7XG4gICAgICAgIGlmIChwYXJhbGxlbFJvdXRlUGF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyZWUgPSBbXG4gICAgICAgIGZsaWdodFNlZ21lbnRQYXRoWzBdLFxuICAgICAgICBfZXh0ZW5kcyh7fSwgcGFyYWxsZWxSb3V0ZXMsIHtcbiAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogcGFyYWxsZWxSb3V0ZVBhdGNoXG4gICAgICAgIH0pLCBcbiAgICBdO1xuICAgIC8vIEN1cnJlbnQgc2VnbWVudCBpcyB0aGUgcm9vdCBsYXlvdXRcbiAgICBpZiAoaXNSb290TGF5b3V0KSB7XG4gICAgICAgIHRyZWVbNF0gPSB0cnVlO1xuICAgIH1cbiAgICAvLyBUT0RPLUFQUDogUmV2aXNpdFxuICAgIC8vIGlmICh1cmwpIHtcbiAgICAvLyAgIHRyZWVbMl0gPSB1cmxcbiAgICAvLyB9XG4gICAgcmV0dXJuIHRyZWU7XG59XG5mdW5jdGlvbiBzaG91bGRIYXJkTmF2aWdhdGUoZmxpZ2h0U2VnbWVudFBhdGgsIGZsaWdodFJvdXRlclN0YXRlLCB0cmVlUGF0Y2gpIHtcbiAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gZmxpZ2h0Um91dGVyU3RhdGU7XG4gICAgLy8gVE9ETy1BUFA6IENoZWNrIGlmIGBhc2AgY2FuIGJlIHJlcGxhY2VkLlxuICAgIGNvbnN0IFtjdXJyZW50U2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleV0gPSBmbGlnaHRTZWdtZW50UGF0aDtcbiAgICAvLyBDaGVjayBpZiBjdXJyZW50IHNlZ21lbnQgbWF0Y2hlcyB0aGUgZXhpc3Rpbmcgc2VnbWVudC5cbiAgICBpZiAoISgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICAvLyBJZiBkeW5hbWljIHBhcmFtZXRlciBpbiB0cmVlIGRvZXNuJ3QgbWF0Y2ggdXAgd2l0aCBzZWdtZW50IHBhdGggYSBoYXJkIG5hdmlnYXRpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50U2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBleGlzdGluZyBzZWdtZW50IGRpZCBub3QgbWF0Y2ggc29mdCBuYXZpZ2F0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0U2VnbWVudCA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyO1xuICAgIGlmIChsYXN0U2VnbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRIYXJkTmF2aWdhdGUoZmxpZ2h0U2VnbWVudFBhdGguc2xpY2UoMiksIHBhcmFsbGVsUm91dGVzW3BhcmFsbGVsUm91dGVLZXldLCB0cmVlUGF0Y2gpO1xufVxuZnVuY3Rpb24gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXh0VHJlZSkge1xuICAgIC8vIENvbXBhcmUgc2VnbWVudHNcbiAgICBjb25zdCBjdXJyZW50VHJlZVNlZ21lbnQgPSBjdXJyZW50VHJlZVswXTtcbiAgICBjb25zdCBuZXh0VHJlZVNlZ21lbnQgPSBuZXh0VHJlZVswXTtcbiAgICAvLyBJZiBhbnkgc2VnbWVudCBpcyBkaWZmZXJlbnQgYmVmb3JlIHdlIGZpbmQgdGhlIHJvb3QgbGF5b3V0LCB0aGUgcm9vdCBsYXlvdXQgaGFzIGNoYW5nZWQuXG4gICAgLy8gRS5nLiAvc2FtZS8oZ3JvdXAxKS9sYXlvdXQuanMgLT4gL3NhbWUvKGdyb3VwMikvbGF5b3V0LmpzXG4gICAgLy8gRmlyc3Qgc2VnbWVudCBpcyAnc2FtZScgZm9yIGJvdGgsIGtlZXAgbG9va2luZy4gKGdyb3VwMSkgY2hhbmdlZCB0byAoZ3JvdXAyKSBiZWZvcmUgdGhlIHJvb3QgbGF5b3V0IHdhcyBmb3VuZCwgaXQgbXVzdCBoYXZlIGNoYW5nZWQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFRyZWVTZWdtZW50KSAmJiBBcnJheS5pc0FycmF5KG5leHRUcmVlU2VnbWVudCkpIHtcbiAgICAgICAgLy8gQ29tcGFyZSBkeW5hbWljIHBhcmFtIG5hbWUgYW5kIHR5cGUgYnV0IGlnbm9yZSB0aGUgdmFsdWUsIGRpZmZlcmVudCB2YWx1ZXMgd291bGQgbm90IGFmZmVjdCB0aGUgY3VycmVudCByb290IGxheW91dFxuICAgICAgICAvLyAvW25hbWVdIC0gL3NsdWcxIGFuZCAvc2x1ZzIsIGJvdGggdmFsdWVzIChzbHVnMSAmIHNsdWcyKSBzdGlsbCBoYXMgdGhlIHNhbWUgbGF5b3V0IC9bbmFtZV0vbGF5b3V0LmpzXG4gICAgICAgIGlmIChjdXJyZW50VHJlZVNlZ21lbnRbMF0gIT09IG5leHRUcmVlU2VnbWVudFswXSB8fCBjdXJyZW50VHJlZVNlZ21lbnRbMl0gIT09IG5leHRUcmVlU2VnbWVudFsyXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRUcmVlU2VnbWVudCAhPT0gbmV4dFRyZWVTZWdtZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBDdXJyZW50IHRyZWUgcm9vdCBsYXlvdXQgZm91bmRcbiAgICBpZiAoY3VycmVudFRyZWVbNF0pIHtcbiAgICAgICAgLy8gSWYgdGhlIG5leHQgdHJlZSBkb2Vzbid0IGhhdmUgdGhlIHJvb3QgbGF5b3V0IGZsYWcsIGl0IG11c3QgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICByZXR1cm4gIW5leHRUcmVlWzRdO1xuICAgIH1cbiAgICAvLyBDdXJyZW50IHRyZWUgIGRpZG4ndCBoYXZlIGl0cyByb290IGxheW91dCBoZXJlLCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgICBpZiAobmV4dFRyZWVbNF0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFdlIGNhbid0IGFzc3VtZSBpdCdzIGBwYXJhbGxlbFJvdXRlcy5jaGlsZHJlbmAgaGVyZSBpbiBjYXNlIHRoZSByb290IGxheW91dCBpcyBgYXBwL0Bzb21ldGhpbmcvbGF5b3V0LmpzYFxuICAgIC8vIEJ1dCBpdCdzIG5vdCBwb3NzaWJsZSB0byBiZSBtb3JlIHRoYW4gb25lIHBhcmFsbGVsUm91dGVzIGJlZm9yZSB0aGUgcm9vdCBsYXlvdXQgaXMgZm91bmRcbiAgICAvLyBUT0RPLUFQUDogY2hhbmdlIHRvIHRyYXZlcnNlIGFsbCBwYXJhbGxlbCByb3V0ZXNcbiAgICBjb25zdCBjdXJyZW50VHJlZUNoaWxkID0gT2JqZWN0LnZhbHVlcyhjdXJyZW50VHJlZVsxXSlbMF07XG4gICAgY29uc3QgbmV4dFRyZWVDaGlsZCA9IE9iamVjdC52YWx1ZXMobmV4dFRyZWVbMV0pWzBdO1xuICAgIGlmICghY3VycmVudFRyZWVDaGlsZCB8fCAhbmV4dFRyZWVDaGlsZCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZUNoaWxkLCBuZXh0VHJlZUNoaWxkKTtcbn1cbmNvbnN0IEFDVElPTl9SRUZSRVNIID0gJ3JlZnJlc2gnO1xuZXhwb3J0cy5BQ1RJT05fUkVGUkVTSCA9IEFDVElPTl9SRUZSRVNIO1xuY29uc3QgQUNUSU9OX05BVklHQVRFID0gJ25hdmlnYXRlJztcbmV4cG9ydHMuQUNUSU9OX05BVklHQVRFID0gQUNUSU9OX05BVklHQVRFO1xuY29uc3QgQUNUSU9OX1JFU1RPUkUgPSAncmVzdG9yZSc7XG5leHBvcnRzLkFDVElPTl9SRVNUT1JFID0gQUNUSU9OX1JFU1RPUkU7XG5jb25zdCBBQ1RJT05fU0VSVkVSX1BBVENIID0gJ3NlcnZlci1wYXRjaCc7XG5leHBvcnRzLkFDVElPTl9TRVJWRVJfUEFUQ0ggPSBBQ1RJT05fU0VSVkVSX1BBVENIO1xuY29uc3QgQUNUSU9OX1BSRUZFVENIID0gJ3ByZWZldGNoJztcbmV4cG9ydHMuQUNUSU9OX1BSRUZFVENIID0gQUNUSU9OX1BSRUZFVENIO1xuLyoqXG4gKiBSZWR1Y2VyIHRoYXQgaGFuZGxlcyB0aGUgYXBwLXJvdXRlciBzdGF0ZSB1cGRhdGVzLlxuICovIGZ1bmN0aW9uIGNsaWVudFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgQUNUSU9OX05BVklHQVRFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgbmF2aWdhdGVUeXBlICwgY2FjaGUgLCBtdXRhYmxlICwgZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiAgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICwgc2VhcmNoICB9ID0gdXJsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdQdXNoID0gbmF2aWdhdGVUeXBlID09PSAncHVzaCc7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNGb3JDdXJyZW50VHJlZSA9IEpTT04uc3RyaW5naWZ5KG11dGFibGUucHJldmlvdXNUcmVlKSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSk7XG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUubXBhTmF2aWdhdGlvbiAmJiBpc0ZvckN1cnJlbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA/IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHZlcmlmeSBtcGFOYXZpZ2F0aW9uIG5vdCBiZWluZyBzZXQgaXMgY29ycmVjdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IG11dGFibGUubXBhTmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIC8gc3RyaWN0IG1vZGUgY2FzZSB3aGVyZSB0aGUgY2FjaGUgYW5kIHRyZWUgd2VyZSBhbHJlYWR5IHBvcHVsYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZS5wYXRjaGVkVHJlZSAmJiBpc0ZvckN1cnJlbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA/IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHZlcmlmeSBtcGFOYXZpZ2F0aW9uIG5vdCBiZWluZyBzZXQgaXMgY29ycmVjdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogbXV0YWJsZS51c2VFeGlzdGluZ0NhY2hlID8gc3RhdGUuY2FjaGUgOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG11dGFibGUucGF0Y2hlZFRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZmV0Y2hWYWx1ZXMgPSBzdGF0ZS5wcmVmZXRjaENhY2hlLmdldChocmVmKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZmV0Y2hWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZsaWdodFNlZ21lbnRQYXRoICwgdHJlZTogbmV3VHJlZSAsIGNhbm9uaWNhbFVybE92ZXJyaWRlICwgIH0gPSBwcmVmZXRjaFZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUucHJldmlvdXNUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG5ld1RyZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFyZE5hdmlnYXRlID0gLy8gVE9ETy1BUFA6IFJldmlzaXQgaWYgdGhpcyBpcyBjb3JyZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoICE9PSBsb2NhdGlvbi5zZWFyY2ggfHwgc2hvdWxkSGFyZE5hdmlnYXRlKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgc3RhdGUudHJlZSwgbmV3VHJlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFyZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHNlZ21lbnRzLnNsaWNlKDEpIHN0cmlwcyAnJywgd2UgY2FuIGdldCByaWQgb2YgJycgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHN1YlRyZWVEYXRhIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN0YXRlLmNhY2hlLnN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoY2FjaGUsIHN0YXRlLmNhY2hlLCBmbGlnaHRTZWdtZW50UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUudXNlRXhpc3RpbmdDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA/IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHBlbmRpbmdQdXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogbXV0YWJsZS51c2VFeGlzdGluZ0NhY2hlID8gc3RhdGUuY2FjaGUgOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gZG9pbmcgYSBoYXJkIHB1c2ggdGhlcmUgY2FuIGJlIHR3byBjYXNlczogd2l0aCBvcHRpbWlzdGljIHRyZWUgYW5kIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2l0aCBvcHRpbWlzdGljIHRyZWUgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiB0aGUgbGF5b3V0cyBoYXZlIGEgbG9hZGluZyBzdGF0ZSAobG9hZGluZy5qcylcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2l0aG91dCBvcHRpbWlzdGljIHRyZWUgY2FzZSBoYXBwZW5zIHdoZW4gdGhlcmUgaXMgbm8gbG9hZGluZyBzdGF0ZSwgaW4gdGhhdCBjYXNlIHdlIHN1c3BlbmQgaW4gdGhpcyByZWR1Y2VyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiBpcyB1c2VkIGZvciBsaW5rcyB0aGF0IGhhdmUgYHByZWZldGNoPXtmYWxzZX1gLlxuICAgICAgICAgICAgICAgIGlmIChmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGZpZ3VyZSBvdXQgc29tZXRoaW5nIGJldHRlciBmb3IgaW5kZXggcGFnZXNcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXN0aWMgdHJlZSBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW1pc3RpYyB0cmVlIGlzIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IHN0YXRlIGxlYXZlIHRoYXQgZGVlcGVyIHBhcnQgb3V0IG9mIHRoZSBmZXRjaFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpbWlzdGljVHJlZSA9IGNyZWF0ZU9wdGltaXN0aWNUcmVlKHNlZ21lbnRzLCBzdGF0ZS50cmVlLCB0cnVlLCBmYWxzZSwgaHJlZik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN0YXRlLmNhY2hlLnN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGV4aXN0aW5nIGNhY2hlIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZSBhbmQgZmlsbCBpbiBgZGF0YWAgcHJvcGVydHkgd2l0aCB0aGUgc3RhcnRlZCBkYXRhIGZldGNoLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYGRhdGFgIHByb3BlcnR5IGlzIHVzZWQgdG8gc3VzcGVuZCBpbiBsYXlvdXQtcm91dGVyIGR1cmluZyByZW5kZXIgaWYgaXQgaGFzbid0IHJlc29sdmVkIHlldCBieSB0aGUgdGltZSBpdCByZW5kZXJzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5KGNhY2hlLCBzdGF0ZS5jYWNoZSwgLy8gVE9ETy1BUFA6IHNlZ21lbnRzLnNsaWNlKDEpIHN0cmlwcyAnJywgd2UgY2FuIGdldCByaWQgb2YgJycgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMuc2xpY2UoMSksICgpPT4oMCwgX2FwcFJvdXRlcikuZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIG9wdGltaXN0aWNUcmVlKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9wdGltaXN0aWMgZmV0Y2ggY291bGRuJ3QgaGFwcGVuIGl0IGZhbGxzIGJhY2sgdG8gdGhlIG5vbi1vcHRpbWlzdGljIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJlcyA9PSBudWxsID8gdm9pZCAwIDogcmVzLmJhaWxPcHRpbWlzdGljKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG9wdGltaXN0aWNUcmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG9wdGltaXN0aWNUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBwZW5kaW5nUHVzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgb3B0aW1pc3RpYyB0cmVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG9wdGltaXN0aWNUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJlbG93IGlzIHRoZSBub3Qtb3B0aW1pc3RpYyBjYXNlLiBEYXRhIGlzIGZldGNoZWQgYXQgdGhlIHJvb3QgYW5kIHN1c3BlbmRlZCB0aGVyZSB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gaW4tZmxpZ2h0IGZldGNoIGF0IHRoZSB0b3AsIHN0YXJ0IGl0LlxuICAgICAgICAgICAgICAgIGlmICghY2FjaGUuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKCgwLCBfYXBwUm91dGVyKS5mZXRjaFNlcnZlclJlc3BvbnNlKHVybCwgc3RhdGUudHJlZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbndyYXAgY2FjaGUgZGF0YSB3aXRoIGB1c2VgIHRvIHN1c3BlbmQgaGVyZSAoaW4gdGhlIHJlZHVjZXIpIHVudGlsIHRoZSBmZXRjaCByZXNvbHZlcy5cbiAgICAgICAgICAgICAgICBjb25zdCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gcmVhZFJlY29yZFZhbHVlKGNhY2hlLmRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBtcGFOYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFwcGx5IHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNhY2hlLmRhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICAgICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGFdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTIpO1xuICAgICAgICAgICAgICAgIC8vIFBhdGggd2l0aG91dCB0aGUgbGFzdCBzZWdtZW50LCByb3V0ZXIgc3RhdGUsIGFuZCB0aGUgc3ViVHJlZURhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC0zKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRyZWUgYmFzZWQgb24gdGhlIGZsaWdodFNlZ21lbnRQYXRoIGFuZCByb3V0ZXIgc3RhdGUgcGF0Y2hcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIF0sIHN0YXRlLnRyZWUsIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTRUdNRU5UIE1JU01BVENIJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUubXBhTmF2aWdhdGlvbiA9IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBuZXdUcmVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBzdWJUcmVlRGF0YSBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3RhdGUuY2FjaGUuc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGV4aXN0aW5nIGNhY2hlIHdpdGggdGhlIHN1YlRyZWVEYXRhIGFwcGxpZWQuXG4gICAgICAgICAgICAgICAgICAgIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShjYWNoZSwgc3RhdGUuY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID8gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIDogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHBlbmRpbmdQdXNoLlxuICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUHVzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgIHRyZWU6IG5ld1RyZWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIEFDVElPTl9TRVJWRVJfUEFUQ0g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmbGlnaHREYXRhICwgcHJldmlvdXNUcmVlICwgb3ZlcnJpZGVDYW5vbmljYWxVcmwgLCBjYWNoZSAsIG11dGFibGUgIH0gPSBhY3Rpb247XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhIGZldGNoIGlzIHNsb3cgdG8gcmVzb2x2ZSBpdCBjb3VsZCBiZSB0aGF0IHlvdSBuYXZpZ2F0ZWQgYXdheSB3aGlsZSB0aGUgcmVxdWVzdCB3YXMgaGFwcGVuaW5nIG9yIGJlZm9yZSB0aGUgcmVkdWNlciBydW5zLlxuICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSBvcHQtb3V0IG9mIGFwcGx5aW5nIHRoZSBwYXRjaCBnaXZlbiB0aGF0IHRoZSBkYXRhIGNvdWxkIGJlIHN0YWxlLlxuICAgICAgICAgICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShwcmV2aW91c1RyZWUpICE9PSBKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogSGFuZGxlIHRyZWUgbWlzbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RSRUUgTUlTTUFUQ0gnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBldmVyeXRoaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtdXRhYmxlLm1wYU5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiB2ZXJpZnkgbXBhTmF2aWdhdGlvbiBub3QgYmVpbmcgc2V0IGlzIGNvcnJlY3QgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUHVzaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBtdXRhYmxlLm1wYU5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCByb3V0ZXIgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjb25jdXJyZW50IHJlbmRlcmluZyAvIHN0cmljdCBtb2RlIGNhc2Ugd2hlcmUgdGhlIGNhY2hlIGFuZCB0cmVlIHdlcmUgYWxyZWFkeSBwb3B1bGF0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUucGF0Y2hlZFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgaHJlZiBhcyBpdCB3YXMgc2V0IGR1cmluZyBuYXZpZ2F0ZSAvIHJlc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA/IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgOiBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHB1c2hSZWYgYXMgc2VydmVyLXBhdGNoIG9ubHkgY2F1c2VzIGNhY2hlL3RyZWUgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjogc3RhdGUucHVzaFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgZm9jdXNBbmRTY3JvbGxSZWYgYXMgc2VydmVyLXBhdGNoIG9ubHkgY2F1c2VzIGNhY2hlL3RyZWUgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCByb3V0ZXIgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG11dGFibGUucGF0Y2hlZFRyZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBmbGlnaHREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5hYmxlIG1wYU5hdmlnYXRpb24gYXMgdGhpcyBpcyBhIG5hdmlnYXRpb24gdGhhdCB0aGUgYXBwLXJvdXRlciBzaG91bGRuJ3QgaGFuZGxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhcHBseSBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyIHN0YXRlIGlzIGtlcHQgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAgICAgICAgICAgICAvLyBTbGljZXMgb2ZmIHRoZSBsYXN0IHNlZ21lbnQgKHdoaWNoIGlzIGF0IC0zKSBhcyBpdCBkb2Vzbid0IGV4aXN0IGluIHRoZSB0cmVlIHlldFxuICAgICAgICAgICAgICAgIGNvbnN0IHRyZWVQYXRoID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoMCwgLTMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt0cmVlUGF0Y2gsIHN1YlRyZWVEYXRhXSA9IGZsaWdodERhdGFQYXRoLnNsaWNlKC0yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICAuLi50cmVlUGF0aFxuICAgICAgICAgICAgICAgIF0sIHN0YXRlLnRyZWUsIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTRUdNRU5UIE1JU01BVENIJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IG92ZXJyaWRlQ2Fub25pY2FsVXJsID8gY3JlYXRlSHJlZkZyb21Vcmwob3ZlcnJpZGVDYW5vbmljYWxVcmwpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG5ld1RyZWUpO1xuICAgICAgICAgICAgICAgIC8vIFJvb3QgcmVmcmVzaFxuICAgICAgICAgICAgICAgIGlmIChmbGlnaHREYXRhUGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHN1YlRyZWVEYXRhIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdGF0ZS5jYWNoZS5zdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKGNhY2hlLCBzdGF0ZS5jYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGhyZWYgYXMgaXQgd2FzIHNldCBkdXJpbmcgbmF2aWdhdGUgLyByZXN0b3JlXG4gICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID8gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIDogc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHB1c2hSZWYgYXMgc2VydmVyLXBhdGNoIG9ubHkgY2F1c2VzIGNhY2hlL3RyZWUgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiBzdGF0ZS5wdXNoUmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGZvY3VzQW5kU2Nyb2xsUmVmIGFzIHNlcnZlci1wYXRjaCBvbmx5IGNhdXNlcyBjYWNoZS90cmVlIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlLFxuICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlOiBjYWNoZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQUNUSU9OX1JFU1RPUkU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1cmwgLCB0cmVlICB9ID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBjYW5vbmljYWwgdXJsXG4gICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjogc3RhdGUucHVzaFJlZixcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgcHJvdmlkZWQgdHJlZVxuICAgICAgICAgICAgICAgICAgICB0cmVlOiB0cmVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gVE9ETy1BUFA6IEFkZCB0ZXN0IGZvciBub3Qgc2Nyb2xsaW5nIHRvIG5lYXJlc3QgbGF5b3V0IHdoZW4gY2FsbGluZyByZWZyZXNoLlxuICAgICAgICAvLyBUT0RPLUFQUDogQWRkIHRlc3QgZm9yIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7cm91dGVyLnB1c2goJy8nKTsgcm91dGVyLnJlZnJlc2goKTt9KSwgdGhhdCBjYXNlIHNob3VsZCBzY3JvbGwuXG4gICAgICAgIGNhc2UgQUNUSU9OX1JFRlJFU0g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjYWNoZSAsIG11dGFibGUgIH0gPSBhY3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IHN0YXRlLmNhbm9uaWNhbFVybDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ZvckN1cnJlbnRUcmVlID0gSlNPTi5zdHJpbmdpZnkobXV0YWJsZS5wcmV2aW91c1RyZWUpID09PSBKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKTtcbiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZS5tcGFOYXZpZ2F0aW9uICYmIGlzRm9yQ3VycmVudFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiB2ZXJpZnkgbXBhTmF2aWdhdGlvbiBub3QgYmVpbmcgc2V0IGlzIGNvcnJlY3QgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUHVzaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBtdXRhYmxlLm1wYU5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCByb3V0ZXIgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjb25jdXJyZW50IHJlbmRlcmluZyAvIHN0cmljdCBtb2RlIGNhc2Ugd2hlcmUgdGhlIGNhY2hlIGFuZCB0cmVlIHdlcmUgYWxyZWFkeSBwb3B1bGF0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUucGF0Y2hlZFRyZWUgJiYgaXNGb3JDdXJyZW50VHJlZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgPyBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlIDogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBwZW5kaW5nUHVzaCAoYWx3YXlzIGZhbHNlIGluIHRoaXMgY2FzZSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiBzdGF0ZS5wdXNoUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgZm9jdXMgYW5kIHNjcm9sbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBtaWdodCBuZWVkIHRvIGRpc2FibGUgdGhpcyBmb3IgRmFzdCBSZWZyZXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogbXV0YWJsZS5wYXRjaGVkVHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmV0Y2ggZGF0YSBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKCgwLCBfYXBwUm91dGVyKS5mZXRjaFNlcnZlclJlc3BvbnNlKG5ldyBVUkwoaHJlZiwgbG9jYXRpb24ub3JpZ2luKSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudHJlZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRyZWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50cmVlWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmV0Y2gnLCBcbiAgICAgICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gcmVhZFJlY29yZFZhbHVlKGNhY2hlLmRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUHVzaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY2FjaGUuZGF0YSBhcyBpdCBoYXMgYmVlbiByZXNvbHZlZCBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgICAgICAgIGNhY2hlLmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBDdXJyZW50bHkgdGhlIEZsaWdodCBkYXRhIGNhbiBvbmx5IGhhdmUgb25lIGl0ZW0gYnV0IGluIHRoZSBmdXR1cmUgaXQgY2FuIGhhdmUgbXVsdGlwbGUgcGF0aHMuXG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0RGF0YVBhdGggPSBmbGlnaHREYXRhWzBdO1xuICAgICAgICAgICAgICAgIC8vIEZsaWdodERhdGFQYXRoIHdpdGggbW9yZSB0aGFuIHR3byBpdGVtcyBtZWFucyB1bmV4cGVjdGVkIEZsaWdodCBkYXRhIHdhcyByZXR1cm5lZFxuICAgICAgICAgICAgICAgIGlmIChmbGlnaHREYXRhUGF0aC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSRUZSRVNIIEZBSUxFRCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdpdmVuIHRoZSBwYXRoIGNhbiBvbmx5IGhhdmUgdHdvIGl0ZW1zIHRoZSBpdGVtcyBhcmUgb25seSB0aGUgcm91dGVyIHN0YXRlIGFuZCBzdWJUcmVlRGF0YSBmb3IgdGhlIHJvb3QuXG4gICAgICAgICAgICAgICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGFdID0gZmxpZ2h0RGF0YVBhdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgIF0sIHN0YXRlLnRyZWUsIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTRUdNRU5UIE1JU01BVENIJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtdXRhYmxlLnByZXZpb3VzVHJlZSA9IHN0YXRlLnRyZWU7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG5ld1RyZWUpO1xuICAgICAgICAgICAgICAgIC8vIFNldCBzdWJUcmVlRGF0YSBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZiwgdGhpcyBkb2Vzbid0IHJldXNlIHRoZSBzdGF0ZS5jYW5vbmljYWxVcmwgYXMgYmVjYXVzZSBvZiBjb25jdXJyZW50IHJlbmRlcmluZyB0aGUgaHJlZiBtaWdodCBjaGFuZ2UgYmV0d2VlbiBkaXNwYXRjaGluZyBhbmQgYXBwbHlpbmcuXG4gICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID8gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIDogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBlbmRpbmdQdXNoIChhbHdheXMgZmFsc2UgaW4gdGhpcyBjYXNlKS5cbiAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjogc3RhdGUucHVzaFJlZixcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IG1pZ2h0IG5lZWQgdG8gZGlzYWJsZSB0aGlzIGZvciBGYXN0IFJlZnJlc2guXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgdHJlZTogbmV3VHJlZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQUNUSU9OX1BSRUZFVENIOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgc2VydmVyUmVzcG9uc2UgIH0gPSBhY3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgW2ZsaWdodERhdGEsIGNhbm9uaWNhbFVybE92ZXJyaWRlXSA9IHNlcnZlclJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBJbXBsZW1lbnQgcHJlZmV0Y2ggZm9yIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gY3JlYXRlSHJlZkZyb21VcmwodXJsKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICAgICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGFdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTIpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBWZXJpZnkgaWYgYG51bGxgIGNhbid0IGJlIHJldHVybmVkIGZyb20gdXNlciBjb2RlLlxuICAgICAgICAgICAgICAgIC8vIElmIHN1YlRyZWVEYXRhIGlzIG51bGwgdGhlIHByZWZldGNoIGRpZCBub3QgcHJvdmlkZSBhIGNvbXBvbmVudCB0cmVlLlxuICAgICAgICAgICAgICAgIGlmIChzdWJUcmVlRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmaWxsQ2FjaGVXaXRoUHJlZmV0Y2hlZFN1YlRyZWVEYXRhKHN0YXRlLmNhY2hlLCBmbGlnaHREYXRhUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodFNlZ21lbnRQYXRoID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgXSwgc3RhdGUudHJlZSwgdHJlZVBhdGNoKTtcbiAgICAgICAgICAgICAgICAvLyBQYXRjaCBkaWQgbm90IGFwcGx5IGNvcnJlY3RseVxuICAgICAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB0cmVlIGJhc2VkIG9uIHRoZSBmbGlnaHRTZWdtZW50UGF0aCBhbmQgcm91dGVyIHN0YXRlIHBhdGNoXG4gICAgICAgICAgICAgICAgc3RhdGUucHJlZmV0Y2hDYWNoZS5zZXQoaHJlZiwge1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXRoIHdpdGhvdXQgdGhlIGxhc3Qgc2VnbWVudCwgcm91dGVyIHN0YXRlLCBhbmQgdGhlIHN1YlRyZWVEYXRhXG4gICAgICAgICAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRyZWUgYmFzZWQgb24gdGhlIGZsaWdodFNlZ21lbnRQYXRoIGFuZCByb3V0ZXIgc3RhdGUgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgdHJlZTogbmV3VHJlZSxcbiAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgYmUgaGl0IGFzIGRpc3BhdGNoIGlzIHN0cm9uZ2x5IHR5cGVkLlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGFjdGlvbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlcnZlclJlZHVjZXIoc3RhdGUsIF9hY3Rpb24pIHtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCByZWR1Y2VyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBzZXJ2ZXJSZWR1Y2VyIDogY2xpZW50UmVkdWNlcjtcbmV4cG9ydHMucmVkdWNlciA9IHJlZHVjZXI7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJyZWR1Y2VyIiwiQUNUSU9OX1BSRUZFVENIIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsIkFDVElPTl9SRVNUT1JFIiwiQUNUSU9OX05BVklHQVRFIiwiQUNUSU9OX1JFRlJFU0giLCJfZXh0ZW5kcyIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX2FwcFJvdXRlckNvbnRleHQiLCJfbWF0Y2hTZWdtZW50cyIsIl9hcHBSb3V0ZXIiLCJjcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUiLCJ0aGVuYWJsZSIsInN0YXR1cyIsInRoZW4iLCJlcnIiLCJyZWFkUmVjb3JkVmFsdWUiLCJ1cmwiLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJpbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwicm91dGVyU3RhdGUiLCJrZXkiLCJzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSIsImNhY2hlS2V5IiwiQXJyYXkiLCJpc0FycmF5IiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwicGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSIsIk1hcCIsImRlbGV0ZSIsInNldCIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwiaGVhZCIsImlzTGFzdFNlZ21lbnQiLCJrZXlzIiwibGVuZ3RoIiwicGFyYWxsZWxSb3V0ZVN0YXRlIiwibmV3Q2FjaGVOb2RlIiwiQ2FjaGVTdGF0ZXMiLCJMQVpZSU5JVElBTElaRUQiLCJkYXRhIiwic3ViVHJlZURhdGEiLCJ1bmRlZmluZWQiLCJmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEiLCJmbGlnaHREYXRhUGF0aCIsImlzTGFzdEVudHJ5IiwicGFyYWxsZWxSb3V0ZUtleSIsInNlZ21lbnQiLCJzZWdtZW50Rm9yQ2FjaGUiLCJleGlzdGluZ0NoaWxkU2VnbWVudE1hcCIsImNoaWxkU2VnbWVudE1hcCIsImV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUiLCJjaGlsZENhY2hlTm9kZSIsIlJFQURZIiwic2xpY2UiLCJpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJmaWxsQ2FjaGVXaXRoUHJlZmV0Y2hlZFN1YlRyZWVEYXRhIiwiZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eSIsInNlZ21lbnRzIiwiZmV0Y2hSZXNwb25zZSIsImJhaWxPcHRpbWlzdGljIiwiREFUQUZFVENIIiwiY3JlYXRlT3B0aW1pc3RpY1RyZWUiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIl9pc0ZpcnN0U2VnbWVudCIsInBhcmVudFJlZmV0Y2giLCJfaHJlZiIsImV4aXN0aW5nU2VnbWVudCIsImV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMiLCJzZWdtZW50TWF0Y2hlcyIsIm1hdGNoU2VnbWVudCIsInNob3VsZFJlZmV0Y2hUaGlzTGV2ZWwiLCJjaGlsZFRyZWUiLCJjaGlsZEl0ZW0iLCJjaGlsZHJlbiIsInJlc3VsdCIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsInRyZWVQYXRjaCIsImlzUm9vdExheW91dCIsInRyZWUiLCJjdXJyZW50U2VnbWVudCIsImxhc3RTZWdtZW50IiwicGFyYWxsZWxSb3V0ZVBhdGNoIiwic2hvdWxkSGFyZE5hdmlnYXRlIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY3VycmVudFRyZWUiLCJuZXh0VHJlZSIsImN1cnJlbnRUcmVlU2VnbWVudCIsIm5leHRUcmVlU2VnbWVudCIsImN1cnJlbnRUcmVlQ2hpbGQiLCJ2YWx1ZXMiLCJuZXh0VHJlZUNoaWxkIiwiY2xpZW50UmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsIm5hdmlnYXRlVHlwZSIsImNhY2hlIiwibXV0YWJsZSIsImZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24iLCJocmVmIiwicGVuZGluZ1B1c2giLCJpc0ZvckN1cnJlbnRUcmVlIiwiSlNPTiIsInN0cmluZ2lmeSIsInByZXZpb3VzVHJlZSIsIm1wYU5hdmlnYXRpb24iLCJjYW5vbmljYWxVcmwiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsInB1c2hSZWYiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5IiwicHJlZmV0Y2hDYWNoZSIsInBhdGNoZWRUcmVlIiwidXNlRXhpc3RpbmdDYWNoZSIsInByZWZldGNoVmFsdWVzIiwibmV3VHJlZSIsImhhcmROYXZpZ2F0ZSIsImxvY2F0aW9uIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwic3BsaXQiLCJwdXNoIiwib3B0aW1pc3RpY1RyZWUiLCJyZXMiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsIkVycm9yIiwib3ZlcnJpZGVDYW5vbmljYWxVcmwiLCJjb25zb2xlIiwibG9nIiwidHJlZVBhdGgiLCJVUkwiLCJvcmlnaW4iLCJzZXJ2ZXJSZXNwb25zZSIsInNlcnZlclJlZHVjZXIiLCJfYWN0aW9uIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/reducer.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/render-from-template-context.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/render-from-template-context.js ***!
  \******************************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = RenderFromTemplateContext;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/compiled/react/index.js\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/shared/lib/app-router-context.js\");\nfunction RenderFromTemplateContext() {\n    _s();\n    const children = (0, _react).useContext(_appRouterContext.TemplateContext);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_s(RenderFromTemplateContext, \"Fd1ieM0FAzMq7OA5+LlfYPV5S7Y=\");\n_c = RenderFromTemplateContext;\n\"use client\";\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=render-from-template-context.js.map\nvar _c;\n$RefreshReg$(_c, \"RenderFromTemplateContext\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtOGRmMmFlZGM0Ny8wL2NhY2hlL25leHQtbnBtLTEzLjAuMy1mYjg3YTE0MjRhLWYxZjZlOGE1NzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEIsSUFBSUMsNEJBQTRCQyxtTkFBZ0U7QUFDaEcsSUFBSUMsU0FBU0YsMEJBQTBCQyxtQkFBT0EsQ0FBQywySkFBTztBQUN0RCxJQUFJRSxvQkFBb0JGLG1CQUFPQSxDQUFDLGtNQUFxQztBQUNyRSxTQUFTRiw0QkFBNEI7O0lBQ2pDLE1BQU1LLFdBQVcsQ0FBQyxHQUFHRixNQUFNLEVBQUVHLFVBQVUsQ0FBQ0Ysa0JBQWtCRyxlQUFlO0lBQ3pFLE9BQU8sV0FBVyxHQUFHSixPQUFPSixPQUFPLENBQUNTLGFBQWEsQ0FBQ0wsT0FBT0osT0FBTyxDQUFDVSxRQUFRLEVBQUUsSUFBSSxFQUFFSjtBQUNyRjtHQUhTTDtLQUFBQTtBQUlUO0FBRUEsSUFBSSxDQUFDLE9BQU9ILFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQ1csVUFBVSxLQUFLLGFBQWE7SUFDcktmLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUUsT0FBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9nQixNQUFNLENBQUNkLFFBQVFFLE9BQU8sRUFBRUY7SUFDL0JlLE9BQU9mLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQsd0RBQXdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC04ZGYyYWVkYzQ3LzAvY2FjaGUvbmV4dC1ucG0tMTMuMC4zLWZiODdhMTQyNGEtZjFmNmU4YTU3NC56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzP2VlNGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG5mdW5jdGlvbiBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0KCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5UZW1wbGF0ZUNvbnRleHQpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbid1c2UgY2xpZW50JztcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiX2FwcFJvdXRlckNvbnRleHQiLCJjaGlsZHJlbiIsInVzZUNvbnRleHQiLCJUZW1wbGF0ZUNvbnRleHQiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/render-from-template-context.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/use-reducer-with-devtools.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/use-reducer-with-devtools.js ***!
  \***************************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useReducerWithReduxDevtools = void 0;\nvar _react = __webpack_require__(/*! react */ \"./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/compiled/react/index.js\");\nfunction normalizeRouterState(val) {\n    if (val instanceof Map) {\n        const obj = {};\n        for (const [key, value] of val.entries()){\n            if (typeof value === \"function\") {\n                obj[key] = \"fn()\";\n                continue;\n            }\n            if (typeof value === \"object\" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value._bundlerConfig) {\n                    obj[key] = \"FlightData\";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (typeof val === \"object\" && val !== null) {\n        const obj1 = {};\n        for(const key1 in val){\n            const value1 = val[key1];\n            if (typeof value1 === \"function\") {\n                obj1[key1] = \"fn()\";\n                continue;\n            }\n            if (typeof value1 === \"object\" && value1 !== null) {\n                if (value1.$$typeof) {\n                    obj1[key1] = value1.$$typeof.toString();\n                    continue;\n                }\n                if (value1.hasOwnProperty(\"_bundlerConfig\")) {\n                    obj1[key1] = \"FlightData\";\n                    continue;\n                }\n            }\n            obj1[key1] = normalizeRouterState(value1);\n        }\n        return obj1;\n    }\n    if (Array.isArray(val)) {\n        return val.map(normalizeRouterState);\n    }\n    return val;\n}\nfunction devToolReducer(fn, ref) {\n    return (state, action)=>{\n        const res = fn(state, action);\n        if (ref.current) {\n            ref.current.send(action, normalizeRouterState(res));\n        }\n        return res;\n    };\n}\nfunction useReducerWithReduxDevtoolsNoop(fn, initialState) {\n    _s();\n    const [state, dispatch] = (0, _react).useReducer(fn, initialState);\n    return [\n        state,\n        dispatch,\n        ()=>{}\n    ];\n}\n_s(useReducerWithReduxDevtoolsNoop, \"6JWkGZ32UPfojeNx+xqn8ZU8A0Q=\");\nfunction useReducerWithReduxDevtoolsImpl(fn, initialState) {\n    _s1();\n    const devtoolsConnectionRef = (0, _react).useRef();\n    const enabledRef = (0, _react).useRef();\n    (0, _react).useEffect(()=>{\n        if (devtoolsConnectionRef.current || enabledRef.current === false) {\n            return;\n        }\n        if (enabledRef.current === undefined && typeof window.__REDUX_DEVTOOLS_EXTENSION__ === \"undefined\") {\n            enabledRef.current = false;\n            return;\n        }\n        devtoolsConnectionRef.current = window.__REDUX_DEVTOOLS_EXTENSION__.connect({\n            instanceId: 1,\n            name: \"next-router\"\n        });\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.init(normalizeRouterState(initialState));\n        }\n        return ()=>{\n            devtoolsConnectionRef.current = undefined;\n        };\n    }, [\n        initialState\n    ]);\n    const [state, dispatch] = (0, _react).useReducer(devToolReducer(/* logReducer( */ fn /*)*/ , devtoolsConnectionRef), initialState);\n    const sync = (0, _react).useCallback(()=>{\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.send({\n                type: \"RENDER_SYNC\"\n            }, normalizeRouterState(state));\n        }\n    }, [\n        state\n    ]);\n    return [\n        state,\n        dispatch,\n        sync\n    ];\n}\n_s1(useReducerWithReduxDevtoolsImpl, \"pLR6zS9fUqATAvEc1j249W8BDm8=\");\nconst useReducerWithReduxDevtools =  true ? useReducerWithReduxDevtoolsImpl : 0;\nexports.useReducerWithReduxDevtools = useReducerWithReduxDevtools;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-reducer-with-devtools.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtOGRmMmFlZGM0Ny8wL2NhY2hlL25leHQtbnBtLTEzLjAuMy1mYjg3YTE0MjRhLWYxZjZlOGE1NzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvdXNlLXJlZHVjZXItd2l0aC1kZXZ0b29scy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsbUNBQW1DLEdBQUcsS0FBSztBQUMzQyxJQUFJRyxTQUFTQyxtQkFBT0EsQ0FBQywySkFBTztBQUM1QixTQUFTQyxxQkFBcUJDLEdBQUcsRUFBRTtJQUMvQixJQUFJQSxlQUFlQyxLQUFLO1FBQ3BCLE1BQU1DLE1BQU0sQ0FBQztRQUNiLEtBQUssTUFBTSxDQUFDQyxLQUFLUixNQUFNLElBQUlLLElBQUlJLE9BQU8sR0FBRztZQUNyQyxJQUFJLE9BQU9ULFVBQVUsWUFBWTtnQkFDN0JPLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHO2dCQUNYLFFBQVM7WUFDYixDQUFDO1lBQ0QsSUFBSSxPQUFPUixVQUFVLFlBQVlBLFVBQVUsSUFBSSxFQUFFO2dCQUM3QyxJQUFJQSxNQUFNVSxRQUFRLEVBQUU7b0JBQ2hCSCxHQUFHLENBQUNDLElBQUksR0FBR1IsTUFBTVUsUUFBUSxDQUFDQyxRQUFRO29CQUNsQyxRQUFTO2dCQUNiLENBQUM7Z0JBQ0QsSUFBSVgsTUFBTVksY0FBYyxFQUFFO29CQUN0QkwsR0FBRyxDQUFDQyxJQUFJLEdBQUc7b0JBQ1gsUUFBUztnQkFDYixDQUFDO1lBQ0wsQ0FBQztZQUNERCxHQUFHLENBQUNDLElBQUksR0FBR0oscUJBQXFCSjtRQUNwQztRQUNBLE9BQU9PO0lBQ1gsQ0FBQztJQUNELElBQUksT0FBT0YsUUFBUSxZQUFZQSxRQUFRLElBQUksRUFBRTtRQUN6QyxNQUFNRSxPQUFNLENBQUM7UUFDYixJQUFJLE1BQU1DLFFBQU9I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O0tBQ0g7QUFDTDtJQXZDU1o7QUF3Q1QsTUFBTTVCLDhCQUE4QixLQUFrQixHQUFjNEIsa0NBQWtDSixDQUErQjtBQUNySTFCLG1DQUFtQyxHQUFHRTtBQUV0QyxJQUFJLENBQUMsT0FBT0YsUUFBUTZDLE9BQU8sS0FBSyxjQUFlLE9BQU83QyxRQUFRNkMsT0FBTyxLQUFLLFlBQVk3QyxRQUFRNkMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPN0MsUUFBUTZDLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktoRCxPQUFPQyxjQUFjLENBQUNDLFFBQVE2QyxPQUFPLEVBQUUsY0FBYztRQUFFNUMsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9pRCxNQUFNLENBQUMvQyxRQUFRNkMsT0FBTyxFQUFFN0M7SUFDL0JnRCxPQUFPaEQsT0FBTyxHQUFHQSxRQUFRNkMsT0FBTztBQUNsQyxDQUFDLENBRUQscURBQXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC04ZGYyYWVkYzQ3LzAvY2FjaGUvbmV4dC1ucG0tMTMuMC4zLWZiODdhMTQyNGEtZjFmNmU4YTU3NC56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy91c2UtcmVkdWNlci13aXRoLWRldnRvb2xzLmpzPzcwMWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB2YWwuZW50cmllcygpKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdmbigpJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUuJCR0eXBlb2YudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5fYnVuZGxlckNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdGbGlnaHREYXRhJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2tleV0gPSBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiB2YWwpe1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWxba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdmbigpJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUuJCR0eXBlb2YudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnX2J1bmRsZXJDb25maWcnKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdGbGlnaHREYXRhJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2tleV0gPSBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXR1cm4gdmFsLm1hcChub3JtYWxpemVSb3V0ZXJTdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBkZXZUb29sUmVkdWNlcihmbiwgcmVmKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKT0+e1xuICAgICAgICBjb25zdCByZXMgPSBmbihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZWYuY3VycmVudC5zZW5kKGFjdGlvbiwgbm9ybWFsaXplUm91dGVyU3RhdGUocmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcChmbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSAoMCwgX3JlYWN0KS51c2VSZWR1Y2VyKGZuLCBpbml0aWFsU3RhdGUpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgKCk9Pnt9XG4gICAgXTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc0ltcGwoZm4sIGluaXRpYWxTdGF0ZSkge1xuICAgIGNvbnN0IGRldnRvb2xzQ29ubmVjdGlvblJlZiA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xuICAgIGNvbnN0IGVuYWJsZWRSZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYoKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50IHx8IGVuYWJsZWRSZWYuY3VycmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlZFJlZi5jdXJyZW50ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZW5hYmxlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQgPSB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXy5jb25uZWN0KHtcbiAgICAgICAgICAgIGluc3RhbmNlSWQ6IDEsXG4gICAgICAgICAgICBuYW1lOiAnbmV4dC1yb3V0ZXInXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50LmluaXQobm9ybWFsaXplUm91dGVyU3RhdGUoaW5pdGlhbFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGluaXRpYWxTdGF0ZVxuICAgIF0pO1xuICAgIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gKDAsIF9yZWFjdCkudXNlUmVkdWNlcihkZXZUb29sUmVkdWNlcigvKiBsb2dSZWR1Y2VyKCAqLyBmbiAvKikqLyAsIGRldnRvb2xzQ29ubmVjdGlvblJlZiksIGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3Qgc3luYyA9ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKCgpPT57XG4gICAgICAgIGlmIChkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFTkRFUl9TWU5DJ1xuICAgICAgICAgICAgfSwgbm9ybWFsaXplUm91dGVyU3RhdGUoc3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgc3RhdGVcbiAgICBdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIHN5bmNcbiAgICBdO1xufVxuY29uc3QgdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNJbXBsIDogdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcDtcbmV4cG9ydHMudXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzID0gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtcmVkdWNlci13aXRoLWRldnRvb2xzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyIsIl9yZWFjdCIsInJlcXVpcmUiLCJub3JtYWxpemVSb3V0ZXJTdGF0ZSIsInZhbCIsIk1hcCIsIm9iaiIsImtleSIsImVudHJpZXMiLCIkJHR5cGVvZiIsInRvU3RyaW5nIiwiX2J1bmRsZXJDb25maWciLCJoYXNPd25Qcm9wZXJ0eSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImRldlRvb2xSZWR1Y2VyIiwiZm4iLCJyZWYiLCJzdGF0ZSIsImFjdGlvbiIsInJlcyIsImN1cnJlbnQiLCJzZW5kIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcCIsImluaXRpYWxTdGF0ZSIsImRpc3BhdGNoIiwidXNlUmVkdWNlciIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc0ltcGwiLCJkZXZ0b29sc0Nvbm5lY3Rpb25SZWYiLCJ1c2VSZWYiLCJlbmFibGVkUmVmIiwidXNlRWZmZWN0IiwidW5kZWZpbmVkIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyIsImNvbm5lY3QiLCJpbnN0YW5jZUlkIiwibmFtZSIsImluaXQiLCJzeW5jIiwidXNlQ2FsbGJhY2siLCJ0eXBlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/client/components/use-reducer-with-devtools.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("./.yarn/__virtual__/next-virtual-8df2aedc47/0/cache/next-npm-13.0.3-fb87a1424a-f1f6e8a574.zip/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=next%2Fdist%2Fclient%2Fcomponents%2Fapp-router&modules=next%2Fdist%2Fclient%2Fcomponents%2Flayout-router&modules=next%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);